데이터를 저장하려면 먼저 **테이블스페이스**를 생성해야한다.
테이블스페이스는 세그먼트를 담는 콘테이너로서, 여러 개의 데이터파일로 구성된다.

테이블스페이스의 구성 요소
테이블스페이스 > 세그먼트 > 익스텐트 > 블록 의 계층 구조로 구성된다.

![](../../images/스크린샷%202026-01-28%2014.28.29.png)

### 테이블스페이스 (Tablespace)
**정의** : 데이터베이스 내에서 데이터를 저장하는 가장 큰 논리적 공간
**특징** : 물리적으로는 여러 개의 **데이터파일 (디스크 상의 물리적인 OS 파일)** 로 구성

### 세그먼트 (Segment)
**정의** : 데이터베이스에서 공간을 차지하는 객체를 의미
**특징** 
- **데이터 세그먼트** : 테이블 안에 저장된 실제 데이터들
- **인덱스 세그먼트** : 설정된 인덱스에 따라 저장된 인덱스 데이터들
**내부 구조** : InnoDB에서 테이블을 하나 만들면 내부적으로 2개의 세그먼트 생성
- Leaf node segment : 실제 데이터
- Non-Leaf node segment : 인덱스 정보
### 익스텐트
**정의** : 세그먼트가 커질 때 공간을 할당받는 단위
**존재 이유*** : 데이터가 늘어날 때마다 블록 단위로 받게 되면 비효율적이므로 데이터를 묶음 단위로 받아오기 위해
**크기** : InnoDB는 보통 1MB 크기로 고정
### 블록
**정의** : 데이터를 읽고 쓰는 최소 단위
**특징** : 만약 `SELECT`로 필요한 데이터 한줄로 요청해도, 그 데이터가 포함된 **블록 전체**를 메모리에 올린다.

- 한 블록은 하나의 테이블이 독점한다.
- 즉, 한 블록에 저장된 레코드는 전부 하나의 테이블 레코드이다.

> MySQL 에서는 페이지(Page) 라고 명함
	 InnoDB는 기본 16KB


![](../../images/스크린샷%202026-01-28%2014.50.59.png)

## 파티션 구조에 따른 세그먼트 저장 방식

**만약 파티션 구조가 아니라면?**
해당 테이블(Order)와 인덱스는 각각 하나의 세그먼트이다.

**만약 파티션 구조라면?***
테이블(Order)를 월별로 파티셔닝했다면?

- **논리적으로는** Order 라는 하나의 테이블이다.
- **물리적으로는** 월별로 별도의 세그먼트로 쪼개져서 저장된다.

## DB 버퍼캐시

SQL을 수행하는 과정에서 자주 읽는 데이터 블록을 매번 디스크에서 읽는 것은 비효율적이다.

디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O 작업을 줄일 수 있다.

![](../../images/스크린샷%202026-01-28%2014.59.30.png)

위 그림과 같이 서버 프로세스와 데이터파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 **항상 버퍼캐시부터 탐색**한다.
### 버퍼 캐시에서 어떻게 블록을 찾나?
1. 해시 알고리즘으로 버퍼 헤더를 찾는다.
2. 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.

**해시 알고리즘 구조**
- 같은 입력 값은 항상 동일한 해시 체인에 연결
- 다른 입력 값이 동일한 해시 체인에 연결될 수 있음
- 정렬 보장하지 않음

**버퍼캐시에 데이터가 없으면** 디스크에서 데이터를 가져와서 버퍼캐시에 적재하고 나서 읽는다!

공유캐시를 사용할 때 두 개의 프로세스가 동시에 접근하지 못한다.
**하나의 프로세스만이 사용**할 수 있으며, 나머지 프로세스들은 대기해야 한다.
## 논리적 I/O vs 물리적 I/O

### 논리적 I/O
**의미** : 버퍼 캐시를 읽는 행위 (메모리 I/O)
- 전기적 신호이고, 물리적 I/O 보다 10,000배는 빠름

**SQL을 실행하면서 읽은 총 블록 I/O가 논리적 I/O임**
### 물리적 I/O
**의미** : **디스크**에서 발생한 총 블록 I/O
- 논리적 I/O 를 해도 데이터가 없을 때 발생
- 이 때 프로세스는 대기 큐에서 잠을 잔다.


### BHCR (Buffer Cache Hit Ratio)
**의미** : 버퍼캐시 효율을 측정하는데 사용하는 지표

`BHCR = (1 - (물리적 I/O) / 논리적 I/O) X 100`

BHCR 은 시스템 상황에 따라 달라지므로 통제 불가능한 변수이다.
물리적 I/O 는 BHCR 에 의해 결정되는데, 이를 통해
**SQL 성능을 높이기 위해서는 논리적 I/O를 개선해야 한다는 것을 알 수 있다.**

## Single Block I/O vs Multiblock I/O

캐시에서 찾지 못해서 **물리적 I/O를 요청할 때** 한번에 **한 블록씩**만 요청하기도 하고, **여러 블록씩** 요청하기도 한다.

### Single Block I/O
 **의미** : 한 번에 한 블록씩만 요청해서 메모리에 적재하는 방식
 **주요 쓰임** : 인덱스 탐색
 - 주로 소량 데이터를 탐색할 때 사용

### Multiblock I/O
**의미**: 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식
**주요 쓰임** : Full Table Scan
- 많은 데이터를 탐색할 때 사용

DBMS 에서는 보통 **1MB 단위로 I/O를 수행**한다.

## Full Table Scan vs Index Range Scan

**시퀀셜 액세스** 
: 논리적 또는 물리적으로 연결된 **순서에 따라 차례대로** 블록을 읽는 방식
- ex) Full Table Scan

**랜덤 액세스**
: 물리적인 순서에 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
- ex) Index Range Scan

### Full Table Scan
**의미** : 시퀀셜 액세스 + Multiblock I/O 방식으로 디스크 블록을 읽음
1. 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고
2. 캐시에서 못 찾으면 **한 번의 수면 상태** 이후에 많은 블록을 한번에 I/O 한다.

**한계** : 소량의 데이터를 찾을 때 위 방법을 사용하게 되면 많은 데이터를 조회하게 되므로 Index Range Scan 이용해야 함

### Index Range Scan
**의미** : 랜덤 액세스 + Single Block I/O 방식

**한계** :
- 캐시에서 블록을 못 찾으면 **레코드 하나를 찾기 위해 매번 수면 상태**가 되어야 하는 매커니즘이다.
- 읽었던 블록을 반복해서 읽는다.

따라서 많은 데이터를 읽을 때는 Full Table Scan 보다 불리하다.

**일반적으로 인덱스를 무조건적으로 사용해서 성능 개선을 시도하지만, 맹신하면 안된다.**

#### 선택 기준

**데이터의 10% 미만 조회 시** : 인덱스 사용
**데이터의 20% 이상 조회 시** : 풀 스캔 사용