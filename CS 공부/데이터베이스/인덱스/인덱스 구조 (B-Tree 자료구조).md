#database 

# 개요
**RDBMS 에서는 B+Tree** 를 완전하게 사용하는 반면에 **MongoDB 는 변형된 B-Tree** 를 사용한다.

MongoDB 는 **리프노드에만 데이터가 저장(B+Tree 특징)** 되지만 **리프 노드 간 연결 리스트는 없다.(B-Tree)**

## B+Tree

![사진](../../../images/b+.png)
**탐색 순서**
key : `14`를 찾는다고 가정
1. 7 < `14` < 15 이므로 사이에 있는 포인터가 가리키는 자식노드로 이동
2. 9 < 11 < `14` 이므로 오른쪽에 있는 포인터로 이동
3. `14`를 찾았으므로 반환
key : `14 ~20 `찾는다고 가정
- B+Tree 는 인접 노드끼리 연결되어 있으므로 **연결 리스트를 따라 순차적으로 조회 가능**
- 루트 노드까지 가지 않고 리프노드에서 연결 리스트를 사용

**특징** 
- 각 노드 내의 데이터들은 항상 정렬된 상태
- 브랜치 노드의 모든 값은 하위 주소를 가지고 있음
- **리프 노드에만** 하나에 여러개의 **데이터(key)와 레코드를 가리키는 주소값(ROWID)** 보유
	- ROWID : 데이터 블록 주소 + row 번호
	- 데이터 블록 주소 : 데이터 파일 번호 + 블록 번호
	- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
	- row 번호 : 블록 내 순번
- 리프 노드끼리는 **앞뒤로 연결(LinkedList)** 되어 있어 서로의 주소값을 가지고 있음
- 루트로부터 리프까지의 높이는 항상 같음


인덱스 탐색과정은 **수직적 탐색** 과 **수평적 탐색**으로 나눌 수 있다.
인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 테이블 레코드를 찾아가기 위한 **주소값 (ROWID)** 을 얻기 위해서이다.

#### ROWID는 논리적 주소다
테이블 레코드와 물리적 연결구조가 아닌, 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다.

### 인덱스를 이용해 테이블 블록을 찾아가는 과정

![](../../../images/스크린샷%202026-01-30%2017.19.25.png)

1. 바로 디스크에서 읽지 않고, **버퍼캐시를 활용**해서 읽고자 하는 DBA를 해시 함수에 입력해서 **해시 체인을 찾고 거기서 해시 헤더를** 찾는다.
	- 캐시에 적재,읽을 때는 같은 해시 함수를 사용하므로 **버퍼 헤더는 항상 같은 해시 체인에 연결**
	- 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 **메모리 주소값을 버퍼 헤더가 가지고 있음**
	- DBA : 데이터파일번호 + 블록번호
2. 얻은 버퍼 헤더로 버퍼 블록을 찾아간다.

#### 인덱스로 테이블 블록을 액세스할 때
- 리프 블록에서 읽은 ROWID를 분해해서 DBA정보를 얻음

#### 테이블을 Full Scan 할 때
- **익스텐트 맵**을 통해 읽을 블록들의 DBA 정보를 얻음

## 인덱스 수직적 탐색

**개념** : 정렬된 인덱스 레코드 중 조건을 만족하는 **첫 번째 레코드를 찾는** 과정이다.
     즉, 인덱스 **시작지점**을 찾는 과정이다.
- 루트, 브랜치 블록에 저장된 각 인덱스 레코드는 **하위 블록에 대한 주소값**을 갖음

-> 조건을 만족하는 첫번째 레코드를 찾는 과정

 **탐색 순서** 
 1. 루트 블록에서 시작
 2. **찾고자 하는 값보다 크거나 같은 값**을 만나면, 바로 **직전 레코드가 가리키는 하위 블록**으로 이동
 3. 마지막 순서의 데이터로 이동하고 그의 직전 데이터로 찾음

**예시**) 14를 찾아라
1. 루트 블록에 14보다 큰 15가 있음
2. 하위 주소인 브랜치 블록에 14보다 큰 값이 없음
3. 마지막 순서의 레코드인 11의 하위 블록으로 이동
4. 14 찾음

## 인덱스 수평적 탐색

수직적 탐색을 통해 스캔 시작점을 찾았으면, **찾고자 하는 데이터가 더 안나타날 때까지** 인덱스 리프 블록을 수평적으로 스캔한다.
- 만약 스캔 시작점과 같은 값들이 여러개면? 
	- 해당 값들의 모든 값들을 탐색하기 위해서 **수평 탐색**을 진행한다.

**목적** 
- 조건절을 만족하는 데이터를 모두 찾기 위해서
- ROWID를 얻기 위해서 
	- ROWID가 필요한 이유는 인덱스를 스캔하고 테이블도 스캔해야할 때 ROWID 가 필요하다



## 인덱스의 물리적 구조

인덱스는 [컬럼 값 + ROWID] 만 저장된 별도의 '색인' 공간이다. 
따라서 원본 데이터를 보려면 ROWID를 통해 테이블로 랜덤 액세스를 해야 한다.
즉, 데이터 테이블의 레코드들을 인덱스 컬럼 값에 해당 하는 레코드들만 복사하여 가지고 있는다.

**커버링 인덱스** 는 쿼리에 필요한 모든 컬럼이 인덱스 안에 포함된 경우이다.
- 데이터가 이미 인덱스에 복사 되어 있으므로, 테이블 접근을 생략하여 성능을 극대화한다.


## B+Tree 가 더 선호되는 이유
- **범위 검색 유리** - 연결 리스트 덕분
- **더 많은 키를 하나의 노드에 저장**
	>B+Tree 의 중간 노드들은 key 값과 자식 노드 포인터만 보유하므로 같은 디스크 블록 크기라도 B-Tree 보다 더 많은 key 를 저장한다.
	> 이로써 트리의 전체 높이가 더 낮게 유지 = 디스크 I/o 횟수 더 낮음 = 검색 속도 증가
	
- **풀스캔 성능 더 좋음**
