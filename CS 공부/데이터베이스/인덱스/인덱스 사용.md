#database 

## 인덱스 선택 기준

1. **조건절에 항상 사용하거나, 자주 사용하는 컬럼으로 선정한다.**
2. **'=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.**
3. **선택도(스캔하는 레코드)가 낮은 컬럼으로 선정한다.** 

### 소트 연산을 생략하기 위한 인덱스 구성 기준

```java
select 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점ID = trt_id;
and 청약일자 between : sbcp1 and sbcp2;
and 입력일자 >= trunc(sysdate-2);
and 계약상태코드 in (ctr1, ctr2, ctr3);
order by 청약일자, 입력자ID
```

`order by` 연산을 생략하기 위해 인덱스를 어떻게 구성해야할까?

1. 먼저 '=' 조건에 있는 취급지점을 선두 컬럼으로 지정한다.
2. 이후에 order by 연산(정렬)을 수행하지 않도록 청약일자, 입력자ID 순으로 지정한다.

인덱스 : [취급지점ID, 청약일자, 입력자ID] 로 구성한다.

이외의 컬럼을 인덱스로 구성할때는 어떤 부분을 생각해야할까?
- 해당 인덱스 컬럼을 가지고 있는 데이터가 많이 없을 때
	- 테이블 랜덤 액세스를 줄일 수 있기 때문에
	- 데이터가 많이 없으면 스캔 횟수가 줄어들기 때문에 데이터가 많을 때는 대체로 사용하지 않는다.

## 복합 인덱스

> 두개 이상의 컬럼을 합쳐서 만든 인덱스

**목적**
- 여러 검색 조건을 한 번에 필터링 하기 위함
- 검색 속도 개선
- 데이터 정렬 효율
- 쿼리 최적화

**컬럼 선택 기준**
- where 절에서 자주 사용되는 컬럼
- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼
- order by 에서 자주 사용되는 컬럼

## 커버링 인덱스

> 쿼리가 필요로 하는 모든 데이터가 인덱스 안에 들어있어서, 실제 데이터 테이블은 접근하지 않아도 되는 상태
> = 필요로 하는 모든 컬럼이 복합 인덱스 안에 들어있는 상태

### 1. `SELECT *` 금지

**상황** : (userId, whiskyId) 로 복합인덱스 설정
**쿼리** : `select * from favorites where user_id = 1`
**문제** : 복합 인덱스로 (userId, whiskyId)를 걸었는데 `SELECT *` 을 실행하게 됨으로써 커버링 인덱스 만족X
	-> 다른 컬럼들도 조회하게 되므로, 풀스캔 발생
**해결** : `select userId from ...` 처럼 인덱스 안에 있는 컬럼으로 쿼리 발생


### 2. 컬럼 순서 고려

**상황** : (userId,whiskyId,createdAt) 로 복합인덱스 설정
**쿼리** 
- `where userId = 1 and whiskyId = 1` : 가능
- `where userId = 1`: 가능
- `where whiskyId = 1 and createdAt = 2000-05-06`: 불가능
	- 앞에 있는 컬럼 없이 뒤에 컬럼부터 사용불가
**해결** : where 절에 가장 자주 쓰이고, 동등 조건으로 사용되는 컬럼부터 앞에 둬야함

### 3. 중복도 고려

>인덱스 컬럼 순서를 정할 때, 중복이 적은 컬럼을 앞에 두는 것이 유리

**상황** 
- (userId,whiskyId) : `userId` 는 식별 값이기 때문에 앞에서 필터링 확실히 됨
- (GENDER,userId) : `GENDER`는 남/여 이기 때문에 변별력이 없어서 필터링 효과 없음

### 4. 운영환경에서의 DB 세팅

실무에서는 DB 변경 사항을 엄격하게 관리하기 때문에 Hibernate 가 맘대로 DB를 건드리지 못하게 함

아래와 같이 `application.yml` 설정을 하고
따로 `schema.sql`파일로 실행시마다 쿼리 날려주거나 따로 쿼리 문으로 인덱스 생성

```yml
spring: 
  sql: 
    init: 
      mode: always
  jpa: 
    hibernate: 
      ddl-auto: none
```

```sql
-- Board 테이블 인덱스 추가
CREATE INDEX idx_board_whisky_created ON board (whisky_id, created_at DESC);
CREATE INDEX idx_board_whisky_comment ON board (whisky_id, comment_count DESC, created_at DESC);
CREATE INDEX idx_board_writer_created ON board (writer_id, created_at DESC);
```

### 5. 쿼리 수행 범위

**상황** : (userId,whiskyId) 복합인덱스 설정
**쿼리** 
- 생성된 인덱스 갯수보다 더 많은 컬럼을 사용할 떄(userId,whiskyId,boardId) 
	- `userId, whiskyId`에 대해 생성된 복합 인덱스를 사용하고 조회하고 남은 `boardId` 는 실제 데이터에서 조회(I/O)
- 생성된 인덱스 갯수보다 더 적은 컬럼을 사용하고 앞에 있는 컬럼일 때(userId)
	- 가장 왼쪽에 있는 `userId`로 인덱스 사용
- 생성된 인덱스 갯수보다 더 적은 컬럼을 사용하고 후순인 컬럼일 때(whiskyId)
	- 복합인덱스의 앞쪽에 있는 컬럼부터 사용해야 하므로 사용 불가(X)
