
## 인덱스를 사용하기 위한 조건

인덱스 선두 컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 Table Full Scan 을 한다. 

인덱스를 **Range Scan** 하려면 인덱스의 **선두 컬럼이 가공되지 않은 상태**여야 한다.

성공적인 Index Range Scan 은 **수직적 탐색과 수평적 탐색을 순차적**으로 해야하는데, 이때 이 수직적 탐색을 하기 위해서는 **스캔할 시작점**을 찾아야 한다. 
근데 인덱스 **선두 컬럼이 가공(%스캔%, where = 연산 형태)되면 시작점을 못 찾기** 때문에 **수직적 탐색을 할 수가 없다.** 인덱스 컬럼이 정렬되어 있지 않게 되어 시작점을 못 찾게 되는 것이다.

**하지만 만약 인덱스가 [성별 + 이름] 이면? (후행 컬럼 '이름'을 가공했을 때)**
쿼리 : `WHERE 성별 = '남' AND 이름 = '홍길동'` 
상황 : 성별이 '남'인 사람들 중에 이름을 변형했더니 '홍길동'이 되는 사람을 찾는 상황

1. '남'인 사람들은 정렬되어 있으므로 수직 탐색으로 시작점을 찾을 수 있다.
2. 이름이 정렬되어 있지만, 가공된 이름(함수)을 찾게 되므로 색인 검출이 안된다.
3. 결국, '남'인 사람들을 모두 읽으면서 `이름 = 홍길동`인 사람을 찾게 된다.

Index Range Scan 이 효율적으로 적용되지 않는다.
'남'인 사람들은 바로 찾았지만, 그 안에 있는 모든 '이름' 데이터를 훑어야 하므로 비효율적으로 사용하게 된다.

인덱스를 정상적으로 사용할 수 없는 예시들 (인덱스가 가공된 상황)
- `where substr(생년월일,5,2) = '05'`
- `where nvl(주문수량, 0) < 100`
- `where 업체명 like '%대한%`'`
- `where (전화번호 = tel or 고객명 = cust)`
- `where 전화번호 in (tel_1, tel_2)`

결론적으로 **인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능**하다.

인덱스가 Range Scan 을 잘 탄다고 해도 **인덱스 성능은 인덱스 스캔 범위, 테이블 액세스 횟수를 얼마나 줄일 수 있는지**에 따라 결정된다.
인덱스를 정말 잘 타는지는 인덱스 **리프 블록에서 스캔하는 양**을 따져봐야 알 수 있다.

## 인덱스를 사용할 수 없는 경우들

### `where`조건에 비교하는 양쪽 데이터 타입이 다를 때

문자형 < 숫자형 < 날짜형 순으로 자동으로 변환해주지만, 정확히 데이터 타입을 맞추는 것이 좋다.

숫자형이 문자형을 이기지만 만약 `LIKE`연산자일 때는 문자열 비교 연산이므로 숫자형이 문자형으로 변환된다.
숫자형 컬럼으로 정렬되어 있는 데이터를 문자형으로 바꾸게 되면 정렬 되어있는 데이터와 무관해지므로 인덱스가 적용이 안된다.

숫자형에 `null` 값이 들어갈 수 밖에 없는 상황이라고 가정해보자.
이때 문자형인 `null` 값으로 넣는 것이 아니라 `to_number(null)`함수로 숫자형으로 바꿔줘야 한다.

## 인덱스를 이용한 소트(정렬) 연산 생략

조건절에서 **'=' 조건**이 붙은 인덱스 컬럼에 한해 정렬 연산은 생략된다.
인덱스를 Range Scan 할 수 있는 이유는 데이터가 정렬되어 있기 때문이다.
찾고자 하는 **데이터가 정렬되어 있는 상태로 모여있기 때문에 필요한 부분만 스캔**한다.

옵티마이저는 이러한 속성을 활용해 SQL에 **`ORDER BY` 가 있어도 정렬 연산을 수행하지 않는다.**
PK 인덱스를 스캔하면서 출력할 때 이미 정렬되어 있는 상태이기 때문이다.

## 정렬 연산을 생략할 수 없는 경우

### `ORDER BY 또는 SELECT-LIST`에서 컬럼을 가공할 때

`where`절 안의 인덱스만 해당하는 것이라고 생각할 수 있지만, `ORDER BY 또는 SELECT-LIST`에서도 컬럼을 가공하지 못하는 상황이 있다.

인덱스에는 가공되지 않은 상태로 저장했는데, `ORDER BY`에서 가공한 값을 기준으로 정렬 연산을 하게 되면 인덱스를 사용할 수 없게 된다.

### `ORDER BY` 에 데이터를 가공할 때

예를 들어, 숫자로 정렬되어 있는 인덱스를 정렬과정에서 문자열로 변환하여 가공하게 되면 정렬 연산을 해야한다.

## 인덱스 스캔 방식

### Index Range Scan
인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 '필요한 범위'만 탐색하는 방식

**발동 조건** : 선두 컬럼을 가공하지 않은 상태로 조건절에 사용

![](../../../images/스크린샷%202026-01-30%2000.13.02.png)

### Index Full Scan
**수직적 탐색 없이** 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
**발동 조건** : 최적의 인덱스가 없을 떄 차선으로 선택

ex) 인덱스가 [이름 + 가격] 일 때 `select * from produce where 가격 > 2000 order by 이름`
**현재 상황**
- 선두 컬럼인 '이름'이 `where`절에 없다 -> 따라서 Index Range Scan 불가능
- 후행 컬럼인 '가격'이 인덱스에 있으므로 수직적 탐색없이 Index Full SCan을 통해 `가격>2000` 인 레코드를 찾을 수 있음

위의 상황처럼 선두 컬럼이 `where` 절에 없으면, 옵티마이저는 먼저 Index Full Scan 을 고려한다.

하지만 만약 **대용량 테이블**이어서 부담이 간다면 Index Full Scan을 고려하지 않을 수 있다.

전체 테이블에 있는 데이터가 `가격 > 2000`인 데이터의 크기보다 훨씬 클 때, `가격 > 2000`인 데이터를 스캔하는 것이 전체 테이블을 스캔하는 것보다 인덱스를 전체 스캔하는 것이 더 효율적이다.
하지만 where 절에 있는 인덱스를 최대한 선두 컬럼을 인덱스로 생성해주는 것이 좋다.

![](../../../images/스크린샷%202026-01-30%2000.13.25.png)

### Index Unique Scan
수직적 탐색만으로 데이터를 찾는 스캔 방식
**발동 조건** : Unique 인덱스를 '=' 조건으로 탐색하는 경우

Unique 인덱스는 중복되는 레코드 값이 없기 때문에 수직적 탐색 이후 수평적 탐색을 할 필요가 없다.
그렇지만 Unique 인덱스라고 하더라도 범위 탐색을 하게 된다면, Index Range Scan을 하게 된다.

### Index Skip Scan
인덱스 **선두 컬럼이 조건절에 없어도** 인덱스를 활용하는 새로운 스캔 방식이다.
**발동 조건** : 조건절에서 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용

Distinct Value 개수가 적은 컬럼 - ex) 성별
Distinct Value 개수가 많은 컬럼 - ex) 고객번호

![](../../../images/스크린샷%202026-01-30%2000.12.48.png)

### Index Fast Full Scan
논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 **Multiblock I/O 방식**으로 스캔한다.
**발동 조건** : 디스크로부터 대량의 인덱스 블록을 읽을 때
- 속도는 빠르지만, 인덱스 리프 노드가 갖는 연결 리스트 구조를 무시한 채 읽어서 순서 보장 X

![](../../../images/스크린샷%202026-01-30%2000.08.22.png)

**Index Full Scan** : 논리적 구조
**스캔 순서** : 루트 -> 브랜치1 -> 1 -> 2 -> 3 -> 4 ~ -> 10 순

**Index Fast Full Scan*** : 물리적 구조
**스캔 순서** : 1 -> 2 -> 10 -> 3 -> ~ 5 -> 6 순




