#인덱스

아래에 제시된 SQL문이 있을 때 리프 블록 어느 지점에서 스캔을 시작(수직적 탐색)하고 어느 지점에서 멈추는지 알아보자.

![](../../../images/스크린샷%202026-01-31%2013.25.59.png)

**LMC** : 키 값을 가진 가장 첫 번째 레코드보다 작거나 같은 값을 갖는 레코드가 저장되어 있음
**수직적 탐색은 스캔 시작점**을 찾는 것이다
### 조건절 1. `where C1 = 'B'`

1. 수직적 탐색을 통해 `C1 = 'B'`인 레코드를 찾고, `'C'`를 만나는 순간 스캔을 멈춘다.
2. 바로 블록3으로 내려가는 것이 아닌 그 직전의 블록2로 내려간다. 
3. 블록2에서 시작점 `C2 = 1` 부터 종료 지점 `C2 = 4`까지 스캔하고 멈춘다.

**스캔 경로** :
**시작점** : 블록 2의 `C1 = B, C2 = 1` 인 지점
**종료 지점** : 블록 3의 `C1 = C` 인 지점

### 조건절 2. `where C1 = 'B' and C2 = 3`

1. 수직적 탐색을 통해 `C1 = 'B'`인 레코드를 찾고, `'C'`를 만나는 순간 스캔을 멈춘다.
2. 바로 블록3으로 내려가는 것이 아닌 그 직전의 블록2로 내려간다. 
3. 리프노드에서 `C2 >= 3` 인ㅇ 첫번째 레코드를 찾고, `C1 = 'C'`를 만날 때까지 스캔하다가 멈춘다.

**스캔 경로** :
**시작점** : 블록 2의 `C1 = 'B', C2 = 3`인 지점
**종료 지점** : 블록 3의 `C2 != 3` 인 지점
### 조건절 3. `where C1 = 'B' and C2 >= 3`

1. 수직적 탐색을 통해 `C1 = 'B'`인 레코드를 찾고, `'C'`를 만나는 순간 스캔을 멈춘다.
2. 바로 블록3으로 내려가는 것이 아닌 그 직전의 블록2로 내려간다.
3. 스캔 시작점이 `C2 >= 3` 부터 스캔한다. 
	-  **수직적 탐색 과정에 이용됨** -> 첫번째 지점을 찾는 것에 이용


**스캔 경로** :
**시작점** : 블록 2의 `C1 = 'B', C2 = 3`인 지점
**종료 지점** : 블록 3의 `C1 != B` 인 지점
### 조건절 4. `where C1 = 'B' and C2 <= 3`

1. 수직적 탐색을 통해 `C1 = 'B'`인 레코드를 찾고, `'C'`를 만나는 순간 스캔을 멈춘다.
2. 바로 블록3으로 내려가는 것이 아닌 그 직전의 블록2로 내려간다.
3. `C1 = B` 인 첫번째 지점부터 `C2 > 3` 이 되는 지점까지 탐색한다.
	- `C2 <= 3` 은 수직적 탐색에 사용되지는 않았지만 종료지점을 찾는 것에 사용
		- 스캔량을 줄이는 역할을 했으

**스캔 경로** :
**시작점** : 블록 2의 `C1 = 'B'`인 지점
**종료 지점** : 블록 3의 `C2 > 3` 인 지점
### 조건절 5. `where C1 = 'B' and C2 between 2 and 3`

1. 수직적 탐색을 통해 `C1 = 'B'`인 레코드를 찾고, `'C'`를 만나는 순간 스캔을 멈춘다.
2. 바로 블록3으로 내려가는 것이 아닌 그 직전의 블록2로 내려간다.
3. `C1 = B 이고 C2 = 2`인 지점에서 시작하고, `C1 != B && C2 > 3` 인 지점에 멈춤
	- 두 개의 조건 모두 시작점과 끝점을 결정 하는 것에 역할을 했음
**스캔 경로** :
**시작점** : 블록 2의 `C1 = 'B', C2 = 2`인 지점
**종료 지점** : 블록 3의 `C2 > 3` 인 지점
### 조건절 6. `where C1 between 'A' and 'C' AND C2 between 2 AND 3`
1. 수직적 탐색을 통해 `C1 = A` 인 레코드를 찾고 그 직전의 LMC 블록부터 스캔한다.
2. 그와 동시에 `C2 = 2`인 지점을 시작점으로 갖고, `C1 = C`, `C2 > 3`인 지점까지 스캔한다.

C1 조건절은 스캔 시작과 끝 지점을 결정했지만, C2는 중간 지점에서 스캔량을 줄이는 데에 거의 역할을 하지 못했다.

## 인덱스 스캔 효율

인덱스를 스캔하는 단계에 처리하는 조건절은 **엑세스 조건**과 **필터 조건**으로 나뉜다.

**인덱스 액세스 조건** 은 인덱스 스캔 범위를 결정하는 조건절이다.
	- 수직적 탐색을 통해 스캔 시작점을 결정하고, 리프 노드에서의 스캔 종료지점을 결정한다.
**인덱스 필터 조건** 은 테이블로 액세스할지를 결정하는 조건절이다.
**테이블 필터 조건** : 인덱스를 이용하든, 테이블을 풀 스캔하든 테이블 액세스 단계에서 처리되는 모든 조건절이다.

### 인덱스를 이용한 테이블 액세스 비용
비용 = 
인덱스 루트와 브랜치 레벨에서 읽는 블록 수
+인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수 
+테이블 액세스 과정에 읽는 블록 수

### 컬럼 순서에 따른 군집성
인덱스에는 **같은 값**을 가지는 레코드들이 서로 군집해 있다.
**'=' 연산자로 조회**하면 조건절을 만족하는 레코드들은 모두 모여 있다.
'=' 연산자가 **아닌 조건절로 조회하면 만족하는 레코드들이 흩어진 상태**가 된다.

Ex) 인덱스 [c1,c2,c3,c4] 로 구성
```sql
where c1 = 1
and c2 <= 'B'
and c3 = '나'
and c4 between 'a' and 'b'
```

- 위의 c1, c2 까지의 조건은 모두 모여있지만, `c2 <= 'B'` 조건으로 인해 c3, c4 조건들을 만족하는 데이터는 모두 흩어진 상태에서 조회해야 한다.
=> 선행 컬럼이 모두 '=' 인 상태에서 범위 검색 조건까지 만족하는 레코드만 모여 있고, **이하의 조건들은 연산자 종류없이 모두 흩어진다.**

여기서의 **인덱스 엑세스 조건** 은 c1,c2 이고, **인덱스 필터 조건**은 c3,c4이다.

### 인덱스 조건이 범위 조건일 때
앞서 본것과 같이 **선행 컬럼이 범위 조건**일 때 **후행 컬럼들은 모여있지 않게** 되므로 효율적인 스캔을 할 수 없다.

#### BETWEEN / LIKE연산 사용할 때 주의사항

1. **인덱스 선두 컬럼에 대한 옵션 조건을 Between/Like 연산자로 처리하면 안된다.**
```sql
select * from 거래
where 고객ID like :cust_id || '%'
and 거래일자 between :dt1 and :dt2
```

고객ID 값을 입력하지 않은 상태에서 스캔을 하게 되면, 모든 거래 데이터를 스캔하면서 거래일자 조건을 필터링하는 상황이 발생한다.

위와 같이 옵션 조건 처리를 했다면, 인덱스를 [거래일자 + 고객ID]순으로 해야한다.
이렇게 하면 거래일자 조건을 부합하는 고객ID를 필터링할 수 있다.

2. **NULL 허용 컬럼에 대해 옵션 조건을 Between/Like 연산자로 처리하면 안된다.
- 결과 집합에서 거래조건에 해당하는 고객ID 가 null 인 데이터는 누락되기 때문이다.




**`between`연산을 `IN`연산으로 바꿔**주면 스캔 횟수를 줄일 수 있다.

Ex) 인덱스 [c1,c2,c3,c4] 로 구성
```sql
where c1 = 1
and c2 between 1 and 3 -> and c2 in (1,2,3)
and c3 = '나'
and c4 = 4
```
이렇게 In 연산으로 바꿔주면 인덱스 수직적 탐색이 3번 발생하기 때문에 스캔 횟수가 줄어든다.

```sql
where c2 = 1

...

where c2 = 2

...

where c2 = 3
```

위와 같이 각 sql 문을 3번 나눠서 한 결과와 같다.

#### `IN` 연산으로 할 때 주의사항
- **범위 안에 있는 항목이 많아지게 되면**, 수직적 탐색도 그만큼 많이 하게 되므로 비효율적이다.
- 스캔 과정에서 레코드들이 **멀리 떨어져 있는 경우에만** 유용하다

Ex) [고객등급 + 고객번호]
```sql
where 고객등급 between 'c' and 'd'
and 고객번호 = 123
```

**`IN` 연산이 효율적인 경우**
- 고객등급 C 와 D 사이에 데이터가 엄청 많은 경우

**`IN` 연산이 비효율적인 경우**
- 고객등급 C 와 D 사이에 데이터가 별로 없는 경우