#database 

## 복합 인덱스

> 두개 이상의 컬럼을 합쳐서 만든 인덱스

**목적**
- 여러 검색 조건을 한 번에 필터링 하기 위함
- 검색 속도 개선
- 데이터 정렬 효율
- 쿼리 최적화

**컬럼 선택 기준**
- where 절에서 자주 사용되는 컬럼
- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼
- order by 에서 자주 사용되는 컬럼

## 커버링 인덱스

> 쿼리가 필요로 하는 모든 데이터가 인덱스 안에 들어있어서, 실제 데이터 테이블은 접근하지 않아도 되는 상태
> = 필요로 하는 모든 컬럼이 복합 인덱스 안에 들어있는 상태

## 주의 사항

### 1. `SELECT *` 금지

**상황** : (userId, whiskyId) 로 복합인덱스 설정
**쿼리** : `select * from favorites where user_id = 1`
**문제** : 복합 인덱스로 (userId, whiskyId)를 걸었는데 `SELECT *` 을 실행하게 됨으로써 커버링 인덱스 만족X
	-> 다른 컬럼들도 조회하게 되므로, 풀스캔 발생
**해결** : `select userId from ...` 처럼 인덱스 안에 있는 컬럼으로 쿼리 발생


### 2. 컬럼 순서 고려

**상황** : (userId,whiskyId,createdAt) 로 복합인덱스 설정
**쿼리** 
- `where userId = 1 and whiskyId = 1` : 가능
- `where userId = 1`: 가능
- `where whiskyId = 1 and createdAt = 2000-05-06`: 불가능
	- 앞에 있는 컬럼 없이 뒤에 컬럼부터 사용불가
**해결** : where 절에 가장 자주 쓰이고, 동등 조건으로 사용되는 컬럼부터 앞에 둬야함

### 3. 중복도 고려

>인덱스 컬럼 순서를 정할 때, 중복이 적은 컬럼을 앞에 두는 것이 유리

**상황** 
- (userId,whiskyId) : `userId` 는 식별 값이기 때문에 앞에서 필터링 확실히 됨
- (GENDER,userId) : `GENDER`는 남/여 이기 때문에 변별력이 없어서 필터링 효과 없음

### 4. 운영환경에서의 DB 세팅

실무에서는 DB 변경 사항을 엄격하게 관리하기 때문에 Hibernate 가 맘대로 DB를 건드리지 못하게 함

아래와 같이 `application.yml` 설정을 하고
따로 `schema.sql`파일로 실행시마다 쿼리 날려주거나 따로 쿼리 문으로 인덱스 생성

```yml
spring: 
  sql: 
    init: 
      mode: always
  jpa: 
    hibernate: 
      ddl-auto: none
```

```sql
-- Board 테이블 인덱스 추가
CREATE INDEX idx_board_whisky_created ON board (whisky_id, created_at DESC);
CREATE INDEX idx_board_whisky_comment ON board (whisky_id, comment_count DESC, created_at DESC);
CREATE INDEX idx_board_writer_created ON board (writer_id, created_at DESC);
```

### 5. 쿼리 수행 범위

**상황** : (userId,whiskyId) 복합인덱스 설정
**쿼리** 
- 생성된 인덱스 갯수보다 더 많은 컬럼을 사용할 떄(userId,whiskyId,boardId) 
	- `userId, whiskyId`에 대해 생성된 복합 인덱스를 사용하고 조회하고 남은 `boardId` 는 실제 데이터에서 조회(I/O)
- 생성된 인덱스 갯수보다 더 적은 컬럼을 사용하고 앞에 있는 컬럼일 때(userId)
	- 가장 왼쪽에 있는 `userId`로 인덱스 사용
- 생성된 인덱스 갯수보다 더 적은 컬럼을 사용하고 후순인 컬럼일 때(whiskyId)
	- 복합인덱스의 앞쪽에 있는 컬럼부터 사용해야 하므로 사용 불가(X)
