트랜잭션이 `COMMIT` 이나 `ROLLBACK` 되고 트랜잭션이 종료되어도 해당 스레드가 가지고 있는 DB 커넥션을 바로 반납하지 않는다.

만약 해당 메서드가 커밋된 이후(`afterCommit()`) 새로운 트랜잭션(`REQUIRES_NEW`)을 열어서 다른 메서드를 수행하도록 하는 상황이 있다고 하자.

나는 처음에 기존의 트랜잭션이 이미 `COMMIT` 된 이후에 새로운 메서드를 실행하니까, 기존의 커넥션 풀은 이미 반납하고 새로운 커넥션 풀을 할당 받아서 작업을 할거라고 생각했다.
결론부터 말하면, 해당 스레드가 후처리의 **트랜잭션 완료가 될 때까지 커넥션을 2개를 점유**하고 있기 때문에 기존의 커넥션은 반납하지 못하는 상황이 유지된다.

## 트랜잭션 3단계 종료 과정

### 1. 물리적 COMMIT or ROLLBACK

- DB 에 물리적으로 `COMMIT` 또는 `ROLLBACK` 하여 데이터를 반영한다.

스레드 : 커넥션 **점유중**

### 2. 동기화 

트랜잭션의 모든 비즈니스 처리가 끝났는 지 확인하는 과정이다.

- **`BEFORE_COMMIT`**: DB에 커밋 명령을 내리기 직전 (커넥션 1개로 추가 작업을 할 수 있는 마지막 기회)
- **`AFTER_COMMIT`**: 커밋이 성공한 직후
- **`AFTER_ROLLBACK`**: 롤백이 일어난 직후

위에 3가지 항목 까지 확인하고 다 수행하면 아래 리스너가 호출되어 종료 상태를 확정 짓는다.
- **`AFTER_COMPLETION`**: 커밋/롤백 여부와 상관없이 모든 비즈니스 처리가 끝난 직후

스레드 : 커넥션 **점유중**

### 3. Cleanup

스레드에 연결된 DB 커넥션과 모든 세션들을 반납하고 연결 해제하는 과정이다.

스레드 : 커넥션 **반납**




