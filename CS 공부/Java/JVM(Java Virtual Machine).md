
# JDK,JRE

**JDK** 에는 **JRE(라이브러리, 개발 도구),** **JVM** 이 포함되어 있다.
![](../../images/스크린샷%202026-01-19%2011.53.19.png)
**JRE** 는 자바 실행환경의 약자로서, 자바 프로그램을 실행시킬 때 필요한 라이브러리 API 를 함께 묶어서 배포되는 패키지이다.
**JVM**은 자바를 돌리는 프로그램이다.
자바로 작성된 프로그램은 *JVM*에서만 실행될 수 있다.

OS에 종속되는 C언어와 달리, 자바는 JVM 위에서만 실행되고 JVM을 거쳐서 OS와 상호작용을 하기 때문에 **OS에 종속되지 않는다.**
즉, OS로부터 독립적으로 프로그램을 제약없이 실행할 수 있다.
> OS에 맞는 JVM 종류는 다르므로, OS에 맞는 JVM을 설치해야 한다.

이것이 가능한 이유는 컴파일된 코드가 해당 하드웨어 OS 환경에 맞게 JVM이 **Byte Code** 로 변환해주기 때문이다.


# JVM 의 동작방식

JVM 은 Byte Code를 클래스 로더를 통해 읽어 자바 API 와 함께 실행한다.

![](../../images/스크린샷%202026-01-19%2011.44.29.png)

1. JVM 은 OS로부터 메모리를 할당받는다.

2. **Java Compiler** 가 소스코드 .java 파일을 .class 파일인 Byte Code 로 컴파일한다.

3. 가상 CPU 인 JVM이 Byte Code 를 기계어로 변환해준다.

4. **Class Loader**는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 실질적으로 메모리를 할당 받아 관리하는 영역인 **Runtime Data Area** 에 올린다.

5. **Runtime Data Area** 에 로딩된 바이트 코드는 **Execution Engine** 을 통해 해석된다.

6. 이 과정에서 **Execution Engine**에 의해 **Garbage Collector 의 작동과 Tread 동기화**가 이루어진다.

# JVM 구성요소

아래 그림은 **Class Loader**, **Exection Engine**, **Runtime Data Area** 를 상세하게 나타낸다.

![](../../images/스크린샷%202026-01-19%2012.16.10.png)

## Class Loader

: JVM 내로 클래스 파일(.class) 을 **동적으로 로드**하고, 링크를 통해 배치하는 작업 수행하는 모듈이다.
-> 로드된 **바이트 코드(.class)들**을 엮에서 JVM 의 메모리 영역인 **Runtime Data Area 에 배치**한다.

클래스를 메모리에 올리는 **로딩 기능은 한번에 메모리에 올리지 않고**, 어플리케이션에서 필요한 경우 **동적으로 메모리에 적재**하게 된다.

#### <로딩 순서>
Loading -> Linking -> Initializing
![](../../images/스크린샷%202026-01-19%2013.12.04.png)

1. **Loading** : 클래스 파일을 가져와서 JCM의 **메모리에 로드**

2. **Linking** : 클래스 파일을 사용하기 위해 검증하는 단계
	1. **Verifying** : 클래스가 JVM 명세세 명시된 대로 구성되어 있는지 검사
	2. **Preparing** : 클래스가 필요로 하는 메모리를 할당
	3. **Resolving** : Symbolic Reference -> Direct Reference

3. **Initializion**  : 클래스 변수들을 적절한 값으로 초기화

## Execution Engine (실행 엔진)

: Class Loader 를 통해 런타임 데이터 영역에 배치된 **바이트 코드를 명령어 단위로 읽어서 실행한다.**

> 자바 Byte Code(.class)는 기계가 바로 수행할 수 있는 언어보다는 가상머신이 이해할 수 있는 중간 레벨로 컴파일된 코드이다.

Execution Engine 은 이러한 Byte Code 를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다.
이 과정에서 **Interpreter와 JIT Compiler** 방식을 혼합하여 바이트 코드를 실행한다.

![](../../images/스크린샷%202026-01-19%2013.25.22.png)

### [Interpreter]

: 바이트 코드 명령어를 하나씩 **읽어서 해석하고 바로 실행**한다.

JVM 안에서 바이트코드는 기본적으로 Interpreter 방식으로 동작한다.
같은 메소드라도 여러 번 호출되면 매번 해석하므로 속도는 느리다.

### [JIT Compiler (Just-In-Time)]

Interpreter 단점을 보완하기 위해 도입된 방식으로,

: **반복되는 코드를 발견**하여 바이트 코드 **전체를 컴파일**하여 **Native Code 로 변경**하고,
이후에는 반복되는 메서드를 **Interpreting 하지 않고 캐싱**해뒀다가 Native Code 로 직접 실행하는 방식이다.

>하나씩 Interpreting 하는 것이 아니라 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 Interpreting 방식보다 빠르다.
  하지만 Native Code 로 변환하는데에도 비용이 소요되므로, Interpreting 방식을 사용하다가 일정 기준이 넘어가면 JIT 방식으로 넘어간다.

### [Garbage Collection(GC)](Garbage%20Collection(GC).md)

: JVM 은 Garbage Collector 가 **힙 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수**한다.

## Runtime Data Area

: JVM 의 메모리 영역으로 자바 애플리케이션을 실행할 때 **사용되는 데이터들을 적재**하는 영역이다.
![](../../images/스크린샷%202026-01-19%2013.46.58.png)

<모든 스레드가 공유해서 사용 (GC의 대상)>
- 힙 역역 (Heap Area)
- 메서드 영역 (Method Area)

<스레드마다 하나씩 생성>
- 스택 영역 (Stack Area)
- PC 레지스터 (PC Register)
- Native 메서드 스택 (Native Method Stack)

### [Method Area]

: JVM이 시작될 때 생성되는 공간으로 **바이트 코드(.class)** 를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 메모리 공간**이다.

JVM이 동작하고 클래스가 로드될 때 적재돼서 **프로그램이 종료될 때까지 저장**된다.
모든 스레드가 공유하는 영역

[저장되는 코드 정보들]
- **Field Info** : 벰버 변수의 이름, 데이터 타입, 접근 제어자의 정보
- **Method Info** : 메소드 이름, 반환 타입, 함수 매개변수, 접근 제어자의 정보
- **Type Info** : class 타입, Type 속성, 

### [Heap Area]

:  JVM 이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역

new 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 Reference Type 이 저장되는 곳

![](../../images/스크린샷%202026-01-19%2014.17.56.png)
힙의 참조 주소는 **"스택 영역"** 이 갖고 있다.
만약 스택 영역에 해당 힙의 참조하는 변수나 필드가 없다면, GC가 해당 객체를 자동으로 제거한다.

힙 영역에서는 GC 를 효율적으로 수행하기 위해서 5가지 영역으로 나뉘고 다시 물리적으로는 두 가지 영역으로 구분된다.
![](../../images/스크린샷%202026-01-19%2014.19.18.png)

**Young Generation** : 생명 주기가 짧은 객체를 GC 대상으로 하는 영역
- **Eden** : 새로 생성된 객체가 오는 첫 위치. 
- **Survivor** : 이전의 영역들이 채워지게 되면 순차적으로 eden-> 1 -> 2 로 이동

**Old Generation** : 생명 주기가 긴 객체를 GC 대상으로 하는 영역. Young Generation 에서 마지막까지 살아남은 객체가 이동

### [Stack Area]

: 기본 자료형을 생성할 때 저장하는 공간으로, **임시적으로 사용되는 변수나 정보들이 저장되는 영역**이다.
스레드마다 하나씩 존재하고, 스레드가 시작될 때 할당된다.

메서드를 호출때마다 
- **스택 프레임이 생성** 
- 메서드 안에서 사용되는 값들을 저장
- 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장
그리고 메서드 수행이 끝나면 각 메서드의 스택 프레임 삭제

#### 스택과 힙에 저장되는 방식이 다르다

- 기본 타입 변수는 스택 영역에 직접 값을 가짐
- 참조타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가짐

ex) `Person p = new Person("최영민",27)`

**Stack Area** : `p` 저장
**Heap Area** : `Person("최영민",27)` 저장

### [PC Register]

: 스레드가 시작될 때 생성되며, 현재 수행중인 **JVM 명령어 주소를 저장하는 공간.**
JVM 명령의 주소는 스레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 가지고 있다.

오직 자바 메서드를 실행할 때의 JVM 명령의 주소를 PC Register 에 저장한다.

### [Native Method Stack]

: 자바 코드가 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역

## Java 의 컴파일과 실행과정

**컴파일(Compile)** : 원시 코드(.java) -> 목적 코드(.class) 로 바꿔주는 것
**링크** : 목적 코드(.class) -> 실행파일로 변환
**빌드** : 원시코드(.java) -> 실행파일로 변환

**실행 과정**

1. 소스코드를 컴파일러가 JVM 이 읽을 수 있는 바이트 코드로 변환한다.
2. 컴파일된 바이트 코드를 클래스 로더가 동적 로딩을 통해 JVM 메모리에 로드한다.
3. JVM 메모리에 적재된 바이트 코드를 Execution Engine 이 실행한다.
## 예상 질문

- JVM 개념과 역할에 대해 설명하라
- JVM의 작동 방식에 대해 설명하라

