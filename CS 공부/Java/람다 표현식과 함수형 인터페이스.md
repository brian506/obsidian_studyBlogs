
## 람다 표현식

자바에서 클래스에서 메서드를 정의해야했다.
하지만 람다식으로 표현하면 메서드의 이름과 반환값을 생략할 수 있고, 이를 변수에 넣어 간결한 코드를 만들 수 있다.

```java
int add(int a, int b) {
	return a + b;
}

// 람다식
(int a, int b) ->> {
	return x + y;
};

(x,y) -> {
	return x + y;
}

(a,b) -> a + b;
```

### 특징
- 람다식 내에서 사용되는 지역변수는 final 이 붙지 않아도 상수로 간주
- 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

### 장점
- 코드를 간결하게 만들 수 있다.
-  식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
-  함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
-  병렬프로그래밍이 용이하다.

### 단점
- 람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.
- 디버깅이 어렵다
- 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
- 재귀로 만들경우 부적합하다.

## 함수형 인터페이스

자바는 순수함수와 일반함수를 다르게 취급하고 있어서, 이를 구분하기 위해 함수형 인터페이스가 등장했다.
함수형 인터페이스는 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 인터페이스에 선언하여 **딱 하나의 추상 메서드**가 선언된 인터페이스를 말한다.

단 인터페이스의 final 상수나 default, static, private 메서드는 추상 메서드가 아니기 때문에, 인터페이스 안에 이들이 여러 개 있어도 추상 메서드가 한개이면 추상메서드이다.

```java

interface Add {
	int add(int x, int y);
}

interface Add {
	int add(int x, int y);
	
	final boolean isNumber = true; // final 상수
    default void print() {}; // 디폴트 메서드
    static void print2() {}; // static 메서드
}
```

### @FunctionalInterface

```java
@FunctionalInterface
public interface MyFunctional {
    public void method();
    public void otherMethod(); // 컴파일 오류 발생
}

```

커스텀 함수형 인터페이스를 만들때 두 개 이상의 추상 메서드가 선언되지 않도록 위 어노테이션이 방어해준다.

## 함수형 인터페이스 종류

### [Supplier]

**역할** : 아무 매개값 없이 리턴값만 반환
**실무 예시** : `Optional.orElseGet()`, 객체 팩토리, 로그 메시지 생성

```java
@FunctionalInterface
public interface Supplier<T> {
	T get();
}

Supplier<String> supplier = () -> "hello";
System.out.println(supplier.get());
```

### [Consumer]

**역할** : 매개값만 받고 처리 (리턴값 X)
**실행  메서드** : `accept()`
**실무 예시** : 로그 기록, 알림 발송, DB 저장 등 부수 실행 처리

```java
@FunctionalInterface
public interface Consumer<T> {
	void accept(T t);


  default Consumer<T> andThen(Consumer<? super T> after) {
	Objects.requireNonNull(after);
	return (T t) -> { accept(t); after.accept(t) };
  }
}

Consumer<String> sendNotifiacation = message -> notificationService.sned(message);
```

`addThen()`: 하나의 함수가 끝난 후 다음 Consumer 를 연쇄적으로 이용할 수 있다.


### [Function]

**역할** : 매핑하기(타입 변환)
**실행 메서드** : `apply()`
여러 데이터 항목들이 들어있는 객체에서 특정 타입 값을 추출하거나 다른 타입으로 변환하는 작업에 사용

```java
@FunctionalInterface
public interface Function<T> {
	R apply(T t);

  default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
	  Objects.requireNonNull(before);
	  return (V, v) -> apply(before.apply(v));
  }

  default <V> Function<V, R> andThen(Function<? super R, ? extends V> after) {
	Objects.requireNonNull(after);
	return (T t) -> { accept(t); after.accept(t) };
  }
  
  static <T> Function<T, T> identity() { return t -> t;}
}

// 예제
// 1. 엔티티를 응답 DTO로 변환하는 함수
Function<Member, MemberResponse> toResponse = member -> new MemberResponse(member.getName(), member.getEmail());

// 2. 대량의 데이터를 변환할 때 활용
List<MemberResponse> responses = members.stream()
        .map(toResponse) // Function 사용
        .toList();
```

`compose()`: 첫번째 함수 실행 이전에 먼저 함수를 실행하여 연쇄적으로 연결해준다.

### [Predicate]

**역할** : 매개값을 받고 true / false 리턴
**실행 메서드** : `test()`

```java
@FunctionalInterface  
public interface Predicate<T> {
	boolean test(T t);
	
	default Predicate<T> and(Predicate<? super T> other) {  
    Objects.requireNonNull(other);  
    return (t) -> test(t) && other.test(t);  
    
    default Predicate<T> negate() {  
    return (t) -> !test(t);  
}
	default Predicate<T> or(Predicate<? super T> other) {  
    Objects.requireNonNull(other);  
    return (t) -> test(t) || other.test(t);  
}

    static <T> Predicate<T> isEqual(Object targetRef) {  
    return (null == targetRef)  
            ? Objects::isNull  
            : object -> targetRef.equals(object);  
}
    
    static <T> Predicate<T> not(Predicate<? super T> target) {  
        Objects.requireNonNull(target);  
        return (Predicate<T>)target.negate();  
    }  
}
}

// 예제
Predicate<String> predicate = s -> s.equals("최영민");
System.out.println(predicate.test("최영민"));
```