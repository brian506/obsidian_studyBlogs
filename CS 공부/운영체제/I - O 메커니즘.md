#네트워크 

**프로세스** 는 **생성**이후 **종료**전까지 **준비**와 **실행**과 **대기** 상태를 반복한다.
총 5가지의 상태를 반복한다.
프로세스는 CPU를 잠깐 빌려 쓴다.

SQL 이 I/O 작업에서 느려지는데, 이를 이해하기 위해 I/O 작업이 어떠한 방식으로 수행되는 지 알아보자.
CPU (나노초)와 디스크 (밀리초)사이에는 100만배 이상의 속도 차이가 존재한다.
프로세스를 I/O 작업이 끝날때까지 붙잡고 있는건 개손해이기 때문에 쓰고 있던 CPU를 반환하여 다른 일부터 수행한다.

## I/O 작업이 시작하게 될 때 프로세스는 어떤 일이 벌어질까

1. **Running** : 프로세스가 CPU 에서 연산 작업을 하고 있다.
2. **I / O 요청** : OS 에다가 디스크에서 데이터를 가져오도록 요청한다.
3. **Blocked / Waiting** : I/O 요청을 하기 위해서 프로세스는 CPU를 OS에 반환하고 잠시 수면 상태에서 I/O가 완료되기를 기다린다.
	- 프로세스는 이때 Waiting Queue에 들어간다.
	- 이때 CPU는 다른 프로세스를 처리하러 떠난다.
4. **Interrupt (완료신호)** : 디스크 컨트롤러가 작업을 마치면 CPU에 전기 신호를 보낸다.
5. **Ready (준비)** : 
	- OS는 작업을 마친 프로세스를 꺠워서 Ready Queue에 넣는다.

## 프로세스가 수면 상태에서 깨어났을 때 작업을 이어서 할까

결론부터 말하면 작업을 이어서 한다.
프로세스가 수면 상태로 될 때 **현재 실행 위치**와 **변수 값** 등을 **PCB(Process Control Block)** 에 저장한다.

프로세스가 이후에 다시 CPU를 할당 받으면 PCB에 저장된 내용을 복구하여, **멈췄던 지점부터 다시 작업을 이어서 한다.**

-> 이 동작을 **컨텍스트 스위칭(Context-Switching)** 이라고 한다.


## 프로세스와 스레드는 같은 개념일까

|**구분**|**프로세스 (Process)**|**스레드 (Thread)**|
|---|---|---|
|**정의**|실행 중인 프로그램 (자원 할당 단위)|프로세스 내 작업 흐름 (실행 단위)|
|**메모리**|독립적 (Code, Data, Heap, Stack 따로)|**공유** (Stack만 따로, 나머진 공유)|
|**통신**|어려움 (IPC 필요)|쉬움 (변수 그냥 공유하면 됨)|
|**오버헤드**|큼 (생성/교환 시 비용 많이 듬)|작음 (가벼움)|
|**안정성**|하나 죽어도 다른 놈 멀쩡함|하나 죽으면 다 같이 죽음|

### 만약 AI 레시피 생성 요청이 들어오면?

**프로세스 구분하기**
나의 스프링 부트 어플리케이션 : 프로세스 A
Ai 모델 : 프로세스 B

-> 두 프로그램은 메모리를 공유하지 않는 다른 프로세스

**스레드 구분하기**
해당 레시피 생성 메서드를 스레드 풀에 있던 스레드가 할당되어 작업 수행

### AI 레시피 생성 (I/O 요청)시 스레드는?

**1. 할당 (Running)** : 스레드가 레시피 생성 메서드를 실행
**2. I/O 요청** : 스레드가 AI 모델에게 HTTP 요청을 보냄
**3. 대기(Blocking / Waiting)** : AI 모델에게 응답이 오기 전까지 해당 스레드는 대기 상태로 변환
	- 이 때 CPU 는 다른 작업 하러감(로그인 처리 등)
**4. 응답 및 재개** : 답이 오면 스레드는 깨어나서 다시 작업 수행
