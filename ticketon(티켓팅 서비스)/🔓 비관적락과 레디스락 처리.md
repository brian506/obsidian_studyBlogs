#backend #project #redis #spring 

# 개요

단일 컴포넌트 내에서 동시성 제어를 하는 방법으로는 [[비관적 락-낙관적 락-레디스 락]]을 많이 사용한다.
낙관락은 보통 병목 현상이 활발히 일어나지 않을 것 같은 구간에 적용하므로 낙관락은 적합하지 않다고 생각했다.

병목 현상이 무조건 일어날 것 같은 구간에 락을 거는 것이 목표이므로 비관락을 적용했고
여러 서버를 이용할 수도 있고 메모리를 이용하여 빠르게 락 획득을 구현할 수 있는 레디스도 같이 적용할 것이다.

**동시에 접속한 사용자들이 티켓 수량을 넘어가지 않도록** 지정한 티켓 수량에 비관락과 레디스락을 걸어 동시성 제어를 하는 것이 목표이다.

아래의 비관적 락과 레디스 락은 하나의 메시지에 각각 DB 연산을 수행했을 때 수행한 것이다.

___

# 📌 비관적 락

### 1. TicketType Entity

```java
public void increaseIssuedQuantity(){
	validateCanIssueTicket();
	this.issuedQuantity++;
}
public void validateCanIssueTicket(){
	if(this.issuedQuantity >= this.maxQuantity){
		throw new ExceededTicketQuantityException(this.getName(),this.getPrice());
	}
}
```

### 2. 락이 걸릴 엔티티에 대한 쿼리 메서드 정의

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@QueryHints({
		@QueryHint(name = "javax.persistence.lock.timeout",value = "3000")
})
@Query("SELECT t FROM TicketType t WHERE t.id = :id")
Optional<TicketType> findByIdForUpdate(@Param("id") Long id);
```

- `@Lock` : 쓰기 잠금 설정
- `QueryHint`: 무한 대기 방지를 위한 타임아웃 3초 지정

#### 🤷🏻 쿼리문은 조회인데 왜 UPDATE 쿼리로 실행되지?

쿼리 자체는 조회 쿼리이지만 쓰기 잠금을 걸었기 때문에 DB 수준에서 `SELECT ... FOR UPDATE`로 변환

 DB 내부 동작 : `SELECT * FROM ticket_type WHERE id =1 FOR UPDATE` 

1. JPA 는 트랜잭션 범위 안에서 ticketType 객체를 영속성 컨텍스트에 등록하고
2. ticketType 내부의 수량 증가 메서드를 통해 객체 필드값이 바뀌면 dirty checking 을 통해
3. 트랜잭션 종료 시점에 자동으로 UPDATE 쿼리를 날린다.

### 3.  트랜잭션 안에서 해당 메서드 호출

```java
@Service
@Qualifier("Pessimitic Lock")
@RequriedArgsContructor
public class PessimisticLockTicketIssueService {
	@Transactional
	public TicketType purchaseTicket(PaymentMessage message, Long memberId){
		Long ticketTypeId = message.getTicketTypeId();
		TicketType ticketType = OptionalUtil.getOrElseThrow(ticketTypeRepository.findByIdForUpdate(ticketTypeId),"티켓타입 조회 실패 ticketType_id = " + ticketTypeId)
		ticketType.validateCanIssueTicket();
		return ticketType;
	}
}
```

- **락은 트랜잭션이 시작된 이후부터 끝날 때까지 유효합니다.**
    
- 즉, `@Transactional` 어노테이션이 제대로 **락을 거는 시점보다 상위에 있어야** 락이 올바르게 작동합니다.
### 4. Entity 수량 갱신 및 저장

### 5. 트랜잭션 commit 시점에 락 해제

___

# 📌 레디스 락 + 비관락

멀티 인스턴스 환경에서의 동시성 제어를 위한 레디스락

### 1. RedissonClient Bean 등록
```java
@Configuration
public class RedissonConfig {

	@Value("${redis.reservation.host}")
	private String redisHost;

	@Value("${redis.reservation.port}")
	private int redisHost;

	@Bean
	public RedissonClient redissonClient(){
		Config config = new Config();
		config.useSingleServer()
			  .setAddress("redis://" + redisHost + ":" + redisHost);
		return Redisson.create(config);
	}
}
```

### 2. RedisService 메서드 호출

```java
@Service
@Qualifier("redisLock")
@RequiredArgsConstructor
public class RedisLockTicketIssueService {
	@Transactional
	public TicketType purchaseTicket(PaymentMessage message,Long memberId){
		String lockName = "ticketTypeLock" + message.getTicketTypeId();
		Long ticketTypeId = message.getTicketTypeId();
		RLock lock = redissonClient.getLock(lockName);
	try{
		boolean available = lock.tryLock(5,3,TimeUnit.SECONDS);
		if(!available){
			throw new RuntimeException("락 획득 실패");
		}
		TicketType ticketType = OptionalUtil.getOrElseThrow(ticketTypeRepository.findByIdForUpdate(ticketTypeId),"티켓 타입 조회 실패 ticket_id= " + ticketTypeId);
		return ticketType;
	}
	catch(InterruptedException e){
		throw new RuntimeException();
	}finally{
		if(lock.isHeldByCurrentThread()){
		lock.unlock();
		}
	}
	}
}
```

분산락을 획득한 사용자는 비관락을 이용한 DB 행 락을 이용하게 된다.

- `lock.tryLock(5,3,TimeUnit.SECONDS)` 
	- waitTime : 락을 얻기 위해 5초간 대기
	- leaseTime : 락 획득 후 자동 해제까지 3초 보장
- `finally{ lock.unlock() }` : 락 해제를 마지막에 반드시 보장
___

# TicketService 

```java
public Ticket saveTicketInfo(PaymentMessage message,Long memberId){
	// 둘 중에 하나 사용
	TicketType ticketType = redisService.purchaseTicket(message,memberId);
	TicketType ticketType = pessimisticService.purchaseTicket(message,memberId);

	Member member = memberRepository.getReferenceById(memberId);
	Ticket ticket = Ticket.createNormalTicket(ticketType,member);

	ticketType.increaseIssuedQuantity();
	return ticketRepository.save(ticket);
}
```

___
#### 🧨 트러블슈팅: 데드락 해결

### 원인
- 락 획득이 트랜잭션 밖에서 일어나고, 이후 DB 접근이 서로 다른 트랜잭션에서 실행되어 데드락 발생
- 티켓 insert 와 티켓 수량 update 간의 락 선점 순서 충돌

### 해결 전략
- 락 획득 → 티켓 수량 증가 → 티켓 생성 → 저장까지 하나의 트랜잭션으로 구성
- 락 획득 순서 통일: ticketType 락 → DB 작업 순서 고정

### 주의할 점
- 락은 획득하는 순서와 위치가 핵심
- 분산락 + 비관락 조합 시 트랜잭션 경계 중요
- 컨트롤러가 아니라 서비스 내에서 락과 비즈니스 로직을 처리해야 안정적

___

## 테스트 코드

```java
@SpringBootTest
@Activate("test")
public class TicketPurchaseLockTest {
	private static final int CONCURRENT_USERS = 100; // 동시 접속자 수 
	private static final Long TICKET_STOCK = 50L; // 티켓 재고
	private Long ticketTypeId;
	private List<Long> ids; // 유저Id 저장 리스트

	@BeforeEach
	void setUp(){
		paymentRepository.deleteAllInBatch();
		ticketRepository.deleteAllInBatch();  
		memberRepository.deleteAllInBatch();  
		eventItemRepository.deleteAllInBatch();  
  
		ids = setupTestData();  
		ticketTypeId = setupTicketType();
	}

	@Test
	void concurrentTest_PessimisticLock() throws InterruptedException{
		//given
		ExecutorService executorService = Executors.newFixedThreadPool(CONCURRENT_USERS)
		CountDownLatch startLatch = new CountDownLatch(1);
		CountDownLatch finishLatch = new CountDownLatch(CONCURRENT_USERS);

		for(int i = 0; i < CONCURRENT_USERS; i++){
			final int index = i;
			executors.submit(() -> {
				try{
					startLatch.await();
					Long memberId = ids.get(index);
					 PaymentMessage message = PaymentMessage.builder()  
                        .ticketTypeId(ticketTypeId)  
                        .memberId(memberId)  
                        .amount(10000)  
                        .paymentKey("payment-key")  
                        .orderId("orderId" + memberId)  
                        .approvedAt(LocalDateTime.now())  
                        .requestedAt(LocalDateTime.now())  
                        .build();  
  
                paymentService.saveTicketAndPayment(message);  
            }catch (InterruptedException e){  
                e.getStackTrace();  
            }finally {  
                finishLatch.countDown(); // 작업 완료  
            }  
        });  
    }  
    //when  
    startLatch.countDown(); // 스레드 시작  
    finishLatch.await(20, TimeUnit.SECONDS); // 종료 대기  
    executorService.shutdown(); // 종료  
  
    //then  
    TicketType result = ticketTypeRepository.findById(ticketTypeId).orElseThrow();  
    List<Ticket> tickets = ticketRepository.findAll();  
  
    Assertions.assertEquals(result.getIssuedQuantity(),TICKET_STOCK);  
    Assertions.assertEquals(tickets.size(),TICKET_STOCK);  
}  
  
@Test  
@DisplayName("100명이 동시에 티켓 구매 요청 시 레디스 락 수행")  
void concurrentTest_redisLock() throws Exception {  
    //given  
    ExecutorService executorService = Executors.newFixedThreadPool(CONCURRENT_USERS);  
    CountDownLatch startLatch = new CountDownLatch(1);  
    CountDownLatch finishLatch = new CountDownLatch(CONCURRENT_USERS);  
  
    for(int i = 0; i < CONCURRENT_USERS; i++){  
        final int index = i;  
        executorService.submit(() -> {  
            try {  
                startLatch.await();  
                Long memberId = ids.get(index);  
                PaymentMessage message = PaymentMessage.builder()  
                        .ticketTypeId(ticketTypeId + index)  
                        .memberId(memberId)  
                        .amount(10000)  
                        .paymentKey("payment-key")  
                        .orderId("orderId" + memberId)  
                        .approvedAt(LocalDateTime.now())  
                        .requestedAt(LocalDateTime.now())  
                        .build();  
                paymentService.saveTicketAndPayment(message);  
            }catch (InterruptedException e){  
                e.getStackTrace();  
            }finally {  
                finishLatch.countDown();  
            }  
        });  
    }  
    //when  
    startLatch.countDown();  
    finishLatch.await(20,TimeUnit.SECONDS);  
    executorService.shutdown();  
  
    //then  
    TicketType ticketType = ticketTypeRepository.findById(ticketTypeId).orElseThrow();  
    List<Ticket> tickets = ticketRepository.findAll();  
  
    Assertions.assertEquals(ticketType.getIssuedQuantity(),TICKET_STOCK);  
    Assertions.assertEquals(tickets.size(),TICKET_STOCK);  
  
}
				}
			})
		}
	}
}
```
- 위의 테스트가 성공한 이후에는 db 안에 데이터들이 사라지지 않아서 yml 에서 create-drop 을 어플리케이션 실행할 때마다 초기화해줄 수 있도록 한다.