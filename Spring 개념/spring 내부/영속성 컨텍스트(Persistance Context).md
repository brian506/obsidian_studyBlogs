#spring 

# 개념

영속성 컨텍스트는 **엔티티를 영구적으로 저장하는 환경**이다. 
JPA 에서 엔티티를 효율적으로 관리하기 위해 사용되는 보이지 않는 저장소이다.

애플리케이션과 데이터베이스 사이에서 객체를 보관하는 일종의 **1차 캐시**라고 볼 수 있다.
___
## 영속성 컨텍스트가 있는 이유

- **1차 캐시** : 한번 조회한 엔티티를 영속성 컨텍스트에 **캐싱**해둔다. 
	- 같은 트랜잭션 내에서 동일한 엔티티를 다시 조회할 때 **DB 에 접근하지 않고 캐시에서 바로** 가져온다.
	
- **쓰기 지연** : `INSERT`, `UPDATE`, `DELETE` 쿼리를 바로 실행하지 않고 SQL 저장소에 모아뒀다가, 트랜잭션이 **커밋될 때 한꺼번에 데이터베이스로** 보낸다.
	 - 이를 통해 DB I/O 횟수를 줄여 성능을 최적화할 수 있다.

- **더티 체킹** : 트랜잭션 안에서 엔티티의 상태를 바꿔주면 영속성 컨텍스트가 변경 사항을 감지하여 트랜잭션 커밋 시점에 **자동으로 `UPDATE` 쿼리를 만들어 실행**해준다.

- **동일성 보장** : 같은 트랜잭션 내에서는 동일한 ID 의 엔티티를 조회하면 항상 같은 인스턴스를 반환한다.

___

## 트랜잭션과 더티 체킹

#### 영속성 컨텍스트는 트랜잭션의 생명주기와 거의 동일하다

- **트랜잭션 시작**: Spring 환경에서는 보통 `@Transactional` 어노테이션이 붙은 메서드가 호출될 때 트랜잭션이 시작된다. 이때 **영속성 컨텍스트도 함께 생성**된다.
    
- **트랜잭션 종료 (Commit)**: 메서드가 성공적으로 종료되면 트랜잭션이 **커밋(Commit)** 된다. 이 시점에 영속성 컨텍스트는 변경된 내용들을 데이터베이스에 동기화(Flush)하고 **사라진다.**
    
- **트랜잭션 종료 (Rollback)**: 메서드에서 예외가 발생하면 트랜잭션은 **롤백(Rollback)** 되며, 영속성 컨텍스트에 있던 모든 변경사항은 DB에 반영되지 않고 그대로 사라진다.

#### 더티 체킹의 동작 원리

**더티 체킹** : 변경 감지라는 뜻으로, 트랜잭션 안에서 엔티티의 변경사항을 감지하여 개발자가`UPDATE` 작업을 하지 않아도 DB에 자동으로 반영해준다.

_동작순서_👉

1.  트랜잭션이 실행되고, 영속성 컨텍스트에 엔티티가 처음 로드될 때 **최초 상태를 복사하여 스냅샷** 으로 만들어 1차 캐시에 저장한다.
2.  리포지토리에 저장 메소드를 이용하지 않고 엔티티 수정 메서드까지 구현한다.

```java
@Transactional  
public void complete(final Long exchangeId) {  
    ExchangeTransaction exchangeTransaction = OptionalUtil.getOrElseThrow(exchangeTransactionRepository.findById(exchangeId), NOT_EXIST_EXCHANGE_ID);  
    exchangeTransaction.setExchangeStatus(ExchangeStatus.COMPLETED);  
}
```

3. **변경 감지**: 트랜잭션이 커밋되는 시점에, JPA는 영속성 컨텍스트를 **플러시(Flush)** 한다. 이때 컨텍스트 안에 있는 모든 엔티티에 대해, **현재 상태와 처음에 저장해 둔 스냅샷을 하나하나 비교** 한다.
4. 변경된 점이 발견되면(dirty), `UPDATE`문을 자동으로 생성하여 쓰기 지연 SQL 저장소에 등록한다.
5. `UPDATE`SQL 을 DB 에 보내고 트랜잭션을 최종적으로 `COMMIT`한다.

#### 주의 사항
- _읽기 전용_ 에서는 더티 체킹을 하지 않는다. 
	 - 클래스 위에 기본값으로 (`readOnly = true` 설정)
- _쓰기 전용_ 에서 더티체킹 가능하다. 
	-  해당 메서드 위에 `@Transaction`이 있어야 한다.