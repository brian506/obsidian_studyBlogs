#spring개념 

## case1 ) Board(게시물) - Comment(댓글)

### Board : Comment = 1 : N (양방향 연관관계일 경우)
- 게시물이 삭제될 때 댓글도 삭제

```java

// Board class ...

@OneToMany(mappedBy = "board", cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)  
private List<Comment> comments = new ArrayList<>();

// Comment class ...

@ManyToOne(fetch = FetchType.LAZY)  
@JoinColumn(name = "board_id")  
private Board board;
```

#### 양방향 연관관계일 경우 주의사항

- `FetchType.LAZY` 를 설정하지 않으면 **N+1 문제** 발생
- `board.getComments()` 로 인한 **N+1 문제** 발생
- **N+1 문제**를 발생시키지 않기 위해서 `board.getComments()` 를 호출하면 안됨


**N+1 문제 예시**
1. `select * from boards` : 1번의 쿼리로 게시물 리스트 10개를 조회
2. `boards.getComment()` 호출
3. `select * from comment where post_id = 1` : 각 게시글마다 댓글 조회 쿼리 N개 실행
4. 총 쿼리 수 = 게시물 조회 쿼리(1번) + 각 게시글의 댓글 조회 쿼리(N번)

##### 게시물이 삭제될 때 댓글도 삭제하고 싶은데?
- 이미 양방향 연관관계로 `cascade = CascadeType.REMOVE`로 설정했기 때문에 알아서 같이 삭제됨
___

### Board : Comment = 1 : N (단방향 연관관계일 경우)

```java

// Comment class ...
@ManyToOne(fetch = FetchType.LAZY)  
@JoinColumn(name = "board_id")  
private Board board;
```

- 자식 객체인 Comment 클래스에서만 단방향 참조
- 부모 객체인 Board 는 Comment 의 존재 여부 모름
- 조회할 때 `CommentRepository` 이용

이렇게 단방향으로 참조하게 되면 **N+1 문제는 발생하지 않음**

- 게시물을 삭제할 때 댓글도 삭제하게 하고 싶으면 `commentRepository.delete()` 쿼리 한번 더 호출해야 됨

**웬만하면 자식 객체 -> 부모 객체 로 단방향 연관관계를 이용하자**

## case 2) 팔로잉 - 팔로워

팔로잉 : 팔로우 = N : M 관계이다.
- N : M 관계를 해소하기 위해  중간 테이블  `Follow` 를 둔다.
- User 엔티티가 셀프 참조하기 때문에 중간 엔티티인 `Follow` 로 해소한다.

```java
// Follow class ...

// 팔로우를 거는 쪽 (로그인 유저)  
@ManyToOne(fetch = FetchType.LAZY)  
@JoinColumn(name = "follower_id", nullable = false)  
private User follower;  
  
// 팔로우 당하는 쪽 (타겟 유저)  
@ManyToOne(fetch = FetchType.LAZY)  
@JoinColumn(name = "following_id", nullable = false)  
private User following;
```
