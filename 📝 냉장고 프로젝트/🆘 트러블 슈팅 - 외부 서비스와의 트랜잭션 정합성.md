
## 개요

사용자가 식재료 정보를 입력할 때 사진을 올리는 상황이다.
사진은 현재 S3 와 연동하여 외부 I/O 작업이 필요하다.

**처음에 생각한 필요조건**
1. 사진을 업로드할 때 별도의 스레드를 할당하여 작업을 비동기적으로 처리한다.
2. 사진 업로드를 DB 작업보다 먼저 수행한다.
3. DB 작업에 실패하면 예외를 던지고, 사진을 삭제한다.

#### 처음에 구현한 코드

![](../../images/스크린샷%202026-01-02%2012.30.38.png)
![](../../images/스크린샷%202026-01-02%2012.41.41.png)

이렇게 `@Async` 로 비동기적으로 메인스레드가 아닌 별도의 스레드를 할당 받아 조금의 지연율을 늦추려고 했다.

`Completable<String>`은 S3 파일 업로드 수행 시에 바로 이미지 파일을 String 타입으로 받지 않을 수도 있으므로 업로드의 유무에 상관없이 `Completable<String>` 타입으로 반환 먼저 한다.

그리고 DB 작업이 실패하면 예외를 던지고, 처음에 업로드 했던 사진 파일을 삭제한다.

##### 발생한 문제점
1. 만약 `try{}`문 안에 있는 로직이 성공은 했는데, DB `COMMIT`단계에서 실패했을 때, `catch` 문까지 도달하지 못하게 된다.
	- 이렇게 되면 `delete()` 가 수행되지 않고 S3 안에 유령 사진 파일이 존재하게 된다.

2. 비동기 방식을 이용해서 S3 작업 자체를 별도로 수행하고자 했는데, `@Aysnc` 를 사용해도 무조건 imageUrl 을 다시 반환 받아야 하기 때문에 DB 커넥션은 계속 점유되어 있는 상태가 된다.
	- **만약 반환받지 않는 상황**이면 비동기 방식으로 스레드 점유를 효율적으로 관리할 수 있다.
	- 그래서 이 상황에서는 `@Async`를 사용한 의미가 없다.

3. 그리고 이 방식으로는 사진 업로드, 사진 삭제 로직을 하나의 DB 커넥션이 점유하게 되므로 한 트랜잭션이 S3 의 생명주기와 같아지게 된다. 이렇게 되면 결국 비동기, 예외 처리 등을 이용한 것에 대한 이득을 보지 못한다.

### 어떻게 해결하면 좋을까?

1. 트랜잭션 커밋 이후에 삭제 로직이 동작하도록 구현해야 한다.
2. 트랜잭션과 외부 I/O 작업이 완벽하게 분리되려면 별도의 클래스에서 처리해야한다.
	- DB 작업만 트랜잭션으로 묶인 하나의 클래스
	- 사진 작업, DB 작업이 하나의 클래스

![](../../images/스크린샷%202026-01-02%2013.19.38.png)![](../../images/스크린샷%202026-01-02%2013.19.51.png)

일단 현재는 이미지 업로드 자체는 한 트랜잭션 내에서 관리하고, 이미지 업로드가 실패했을 때 정확하게 롤백 처리가 되고 나서 삭제 로직이 수행되도록 한다.

`status == STATUS_ROLLED_BACK` 인 상태일 때 해당 메서드 `runOnRollback` 이 동작한다.


___
#### TransactionSynchronization ?

> 이 인터페이스는 트랜잭션의 생명주기에 따라 호출되는 콜백 인터페이스이다.

트랜잭션 자체적으로 성공 여부를 정확히 알려주고, 성공 여부에 따라 이후의 작업을 수행할 때 필요한 인터페이스이다.

이 인터페이스는 내부적으로 `ThreadLocal` 을 사용하고, 이는 같은 요청을 사용하는 동일한 스레드 내에서만 트랜잭션 정보를 서로 공유하게 된다.
이를 통해 원자적으로 각 트랜잭션의 상태를 알 수 있다.

