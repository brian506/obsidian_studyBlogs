#database #mysql 

# 개요

게시물 종류
1. 사용자가 즐겨찾기 추가한 위스키의 게시글에 대한 피드
2. 사용자가 팔로잉한 사용자가 게시한 게시글에 대한 피드

두개의 피드 모두 최신순, 오래된순, 인기순, 조회순 정렬 가능

## 사용자가 즐겨찾기 추가한 위스키의 게시글에 대한 피드

### 1. 사용자의 즐겨찾기 위스키 필터링

```sql
SELECT * FROM board b 
JOIN user_whisky_favorites f 
ON f.whisky_id = b.whisky_id 
WHERE f.user_id = :userId 
AND (커서 조건) ORDER BY (정렬 조건)
```

- 먼저 `userId`를 이용해서 사용자의 위스키 목록들을 뽑아낸다.
- 뽑아낸 위스키 목록들 중에서 Board 테이블과 **조인**하기 위한 `whiskyId` 로 인덱스를 걸어준다.

**Index** : {`userId, whiskyId}` - 위스키즐겨찾기Entity 에 복합인덱스 설정

##### 🔥 사용자가 즐겨찾기 할때마다 쓰기작업(UPDATE)이 일어날텐데 이렇게 인덱스를 걸어줘도 될까?

비용측면에서 생각해보자,
사용자가 즐겨찾기 추가한 횟수(`UPDATE`) < 데이터 조회 횟수 일것이다.
즉, 읽기 빈도가 쓰기 빈도보다 압도적으로 높기 때문에 훨씬 이득

### 2. 정렬 - 최신순, 인기순(댓글순)

```sql
// 최신순
ORDER BY created_at DESC;

// 인기순
ORDER BY comment_count DESC, created_at DESC;
```

**최신순 Index** : {`whiskyId, createdAt`} - Board Entity 에 복합인덱스 설정
**인기순 Index** :  {`whiskyId, commentCount, createdAt`} - Board Entity 에 복합 인덱스 설정

## 사용자가 팔로잉한 사용자가 게시한 게시글에 대한 피드


```sql
SELECT * FROM board b
JOIN user_board_follow f ON f.following_id = b.writer_id
WHERE f.follower_id = :userId
  AND (커서 조건)
ORDER BY (정렬 조건)
```

### 1. 팔로잉한 목록 필터링

- 사용자가 팔로잉한 사람들 목록부터 필터링
**Index** : {`followerId,followingId`} - 팔로잉 인덱스 에 복합인덱스 설정

### 2. writerId(followingId) = 조인키

- 팔로잉한 사람들이 쓴 글을 최신순으로 조회
**Index** : {`writerId, createdAt`} - Board 테이블에 복합인덱스 설정