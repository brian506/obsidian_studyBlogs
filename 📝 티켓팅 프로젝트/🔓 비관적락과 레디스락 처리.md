#backend #project #redis #spring 

# ê°œìš”

ë‹¨ì¼ ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ë™ì‹œì„± ì œì–´ë¥¼ í•˜ëŠ” ë°©ë²•ìœ¼ë¡œëŠ” [[../CS ê³µë¶€/ë°ì´í„°ë² ì´ìŠ¤/ë™ì‹œì„± ì œì–´/Synchronized-ë¹„ê´€ì  ë½-ë‚™ê´€ì  ë½-ë ˆë””ìŠ¤ ë¶„ì‚°ë½]]ì„ ë§ì´ ì‚¬ìš©í•œë‹¤.
ë‚™ê´€ë½ì€ ë³´í†µ ë³‘ëª© í˜„ìƒì´ í™œë°œíˆ ì¼ì–´ë‚˜ì§€ ì•Šì„ ê²ƒ ê°™ì€ êµ¬ê°„ì— ì ìš©í•˜ë¯€ë¡œ ë‚™ê´€ë½ì€ ì í•©í•˜ì§€ ì•Šë‹¤ê³  ìƒê°í–ˆë‹¤.

ë³‘ëª© í˜„ìƒì´ ë¬´ì¡°ê±´ ì¼ì–´ë‚  ê²ƒ ê°™ì€ êµ¬ê°„ì— ë½ì„ ê±°ëŠ” ê²ƒì´ ëª©í‘œì´ë¯€ë¡œ ë¹„ê´€ë½ì„ ì ìš©í–ˆê³ 
ì—¬ëŸ¬ ì„œë²„ë¥¼ ì´ìš©í•  ìˆ˜ë„ ìˆê³  ë©”ëª¨ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ë¹ ë¥´ê²Œ ë½ íšë“ì„ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ë ˆë””ìŠ¤ë„ ê°™ì´ ì ìš©í•  ê²ƒì´ë‹¤.

**ë™ì‹œì— ì ‘ì†í•œ ì‚¬ìš©ìë“¤ì´ í‹°ì¼“ ìˆ˜ëŸ‰ì„ ë„˜ì–´ê°€ì§€ ì•Šë„ë¡** ì§€ì •í•œ í‹°ì¼“ ìˆ˜ëŸ‰ì— ë¹„ê´€ë½ê³¼ ë ˆë””ìŠ¤ë½ì„ ê±¸ì–´ ë™ì‹œì„± ì œì–´ë¥¼ í•˜ëŠ” ê²ƒì´ ëª©í‘œì´ë‹¤.

ì•„ë˜ì˜ ë¹„ê´€ì  ë½ê³¼ ë ˆë””ìŠ¤ ë½ì€ í•˜ë‚˜ì˜ ë©”ì‹œì§€ì— ê°ê° DB ì—°ì‚°ì„ ìˆ˜í–‰í–ˆì„ ë•Œ ìˆ˜í–‰í•œ ê²ƒì´ë‹¤.

___

# ğŸ“Œ ë¹„ê´€ì  ë½

### 1. TicketType Entity

```java
public void increaseIssuedQuantity(){
	validateCanIssueTicket();
	this.issuedQuantity++;
}
public void validateCanIssueTicket(){
	if(this.issuedQuantity >= this.maxQuantity){
		throw new ExceededTicketQuantityException(this.getName(),this.getPrice());
	}
}
```

### 2. ë½ì´ ê±¸ë¦´ ì—”í‹°í‹°ì— ëŒ€í•œ ì¿¼ë¦¬ ë©”ì„œë“œ ì •ì˜

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@QueryHints({
		@QueryHint(name = "javax.persistence.lock.timeout",value = "3000")
})
@Query("SELECT t FROM TicketType t WHERE t.id = :id")
Optional<TicketType> findByIdForUpdate(@Param("id") Long id);
```

- `@Lock` : ì“°ê¸° ì ê¸ˆ ì„¤ì •
- `QueryHint`: ë¬´í•œ ëŒ€ê¸° ë°©ì§€ë¥¼ ìœ„í•œ íƒ€ì„ì•„ì›ƒ 3ì´ˆ ì§€ì •

#### ğŸ¤·ğŸ» ì¿¼ë¦¬ë¬¸ì€ ì¡°íšŒì¸ë° ì™œ UPDATE ì¿¼ë¦¬ë¡œ ì‹¤í–‰ë˜ì§€?

ì¿¼ë¦¬ ìì²´ëŠ” ì¡°íšŒ ì¿¼ë¦¬ì´ì§€ë§Œ ì“°ê¸° ì ê¸ˆì„ ê±¸ì—ˆê¸° ë•Œë¬¸ì— DB ìˆ˜ì¤€ì—ì„œ `SELECT ... FOR UPDATE`ë¡œ ë³€í™˜

 DB ë‚´ë¶€ ë™ì‘ : `SELECT * FROM ticket_type WHERE id =1 FOR UPDATE` 

1. JPA ëŠ” íŠ¸ëœì­ì…˜ ë²”ìœ„ ì•ˆì—ì„œ ticketType ê°ì²´ë¥¼ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ì— ë“±ë¡í•˜ê³ 
2. ticketType ë‚´ë¶€ì˜ ìˆ˜ëŸ‰ ì¦ê°€ ë©”ì„œë“œë¥¼ í†µí•´ ê°ì²´ í•„ë“œê°’ì´ ë°”ë€Œë©´ dirty checking ì„ í†µí•´
3. íŠ¸ëœì­ì…˜ ì¢…ë£Œ ì‹œì ì— ìë™ìœ¼ë¡œ UPDATE ì¿¼ë¦¬ë¥¼ ë‚ ë¦°ë‹¤.

### 3.  íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ í•´ë‹¹ ë©”ì„œë“œ í˜¸ì¶œ

```java
@Service
@Qualifier("Pessimitic Lock")
@RequriedArgsContructor
public class PessimisticLockTicketIssueService {
	@Transactional
	public TicketType purchaseTicket(PaymentMessage message, Long memberId){
		Long ticketTypeId = message.getTicketTypeId();
		TicketType ticketType = OptionalUtil.getOrElseThrow(ticketTypeRepository.findByIdForUpdate(ticketTypeId),"í‹°ì¼“íƒ€ì… ì¡°íšŒ ì‹¤íŒ¨ ticketType_id = " + ticketTypeId)
		ticketType.validateCanIssueTicket();
		return ticketType;
	}
}
```

- **ë½ì€ íŠ¸ëœì­ì…˜ì´ ì‹œì‘ëœ ì´í›„ë¶€í„° ëë‚  ë•Œê¹Œì§€ ìœ íš¨í•©ë‹ˆë‹¤.**
    
- ì¦‰, `@Transactional` ì–´ë…¸í…Œì´ì…˜ì´ ì œëŒ€ë¡œ **ë½ì„ ê±°ëŠ” ì‹œì ë³´ë‹¤ ìƒìœ„ì— ìˆì–´ì•¼** ë½ì´ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•©ë‹ˆë‹¤.
### 4. Entity ìˆ˜ëŸ‰ ê°±ì‹  ë° ì €ì¥

### 5. íŠ¸ëœì­ì…˜ commit ì‹œì ì— ë½ í•´ì œ

___

# ğŸ“Œ ë ˆë””ìŠ¤ ë½ + ë¹„ê´€ë½

ë©€í‹° ì¸ìŠ¤í„´ìŠ¤ í™˜ê²½ì—ì„œì˜ ë™ì‹œì„± ì œì–´ë¥¼ ìœ„í•œ ë ˆë””ìŠ¤ë½

### 1. RedissonClient Bean ë“±ë¡
```java
@Configuration
public class RedissonConfig {

	@Value("${redis.reservation.host}")
	private String redisHost;

	@Value("${redis.reservation.port}")
	private int redisHost;

	@Bean
	public RedissonClient redissonClient(){
		Config config = new Config();
		config.useSingleServer()
			  .setAddress("redis://" + redisHost + ":" + redisHost);
		return Redisson.create(config);
	}
}
```

### 2. RedisService ë©”ì„œë“œ í˜¸ì¶œ

```java
@Service
@Qualifier("redisLock")
@RequiredArgsConstructor
public class RedisLockTicketIssueService {
	@Transactional
	public TicketType purchaseTicket(PaymentMessage message,Long memberId){
		String lockName = "ticketTypeLock" + message.getTicketTypeId();
		Long ticketTypeId = message.getTicketTypeId();
		RLock lock = redissonClient.getLock(lockName);
	try{
		boolean available = lock.tryLock(5,3,TimeUnit.SECONDS);
		if(!available){
			throw new RuntimeException("ë½ íšë“ ì‹¤íŒ¨");
		}
		TicketType ticketType = OptionalUtil.getOrElseThrow(ticketTypeRepository.findByIdForUpdate(ticketTypeId),"í‹°ì¼“ íƒ€ì… ì¡°íšŒ ì‹¤íŒ¨ ticket_id= " + ticketTypeId);
		return ticketType;
	}
	catch(InterruptedException e){
		throw new RuntimeException();
	}finally{
		if(lock.isHeldByCurrentThread()){
		lock.unlock();
		}
	}
	}
}
```

ë¶„ì‚°ë½ì„ íšë“í•œ ì‚¬ìš©ìëŠ” ë¹„ê´€ë½ì„ ì´ìš©í•œ DB í–‰ ë½ì„ ì´ìš©í•˜ê²Œ ëœë‹¤.

- `lock.tryLock(5,3,TimeUnit.SECONDS)` 
	- waitTime : ë½ì„ ì–»ê¸° ìœ„í•´ 5ì´ˆê°„ ëŒ€ê¸°
	- leaseTime : ë½ íšë“ í›„ ìë™ í•´ì œê¹Œì§€ 3ì´ˆ ë³´ì¥
		- ë½ íšë“ ê³¼ì •ì—ì„œ ì„œë²„ê°€ ì£½ì–´ë²„ë¦¬ë©´ ë½ì´ ì˜ì›íˆ í•´ì œë˜ì§€ ì•Šì•„ ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•¨(ë°ë“œë½ ë°©ì§€)
- `finally{ lock.unlock() }` : ë½ í•´ì œë¥¼ ë§ˆì§€ë§‰ì— ë°˜ë“œì‹œ ë³´ì¥
___

# TicketService 

```java
public Ticket saveTicketInfo(PaymentMessage message,Long memberId){
	// ë‘˜ ì¤‘ì— í•˜ë‚˜ ì‚¬ìš©
	TicketType ticketType = redisService.purchaseTicket(message,memberId);
	TicketType ticketType = pessimisticService.purchaseTicket(message,memberId);

	Member member = memberRepository.getReferenceById(memberId);
	Ticket ticket = Ticket.createNormalTicket(ticketType,member);

	ticketType.increaseIssuedQuantity();
	return ticketRepository.save(ticket);
}
```

___
#### ğŸ§¨ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…: ë°ë“œë½ í•´ê²°

### ì›ì¸
- ë½ íšë“ì´ íŠ¸ëœì­ì…˜ ë°–ì—ì„œ ì¼ì–´ë‚˜ê³ , ì´í›„ DB ì ‘ê·¼ì´ ì„œë¡œ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ ì‹¤í–‰ë˜ì–´ ë°ë“œë½ ë°œìƒ
- í‹°ì¼“ insert ì™€ í‹°ì¼“ ìˆ˜ëŸ‰ update ê°„ì˜ ë½ ì„ ì  ìˆœì„œ ì¶©ëŒ

### í•´ê²° ì „ëµ
- ë½ íšë“ â†’ í‹°ì¼“ ìˆ˜ëŸ‰ ì¦ê°€ â†’ í‹°ì¼“ ìƒì„± â†’ ì €ì¥ê¹Œì§€ í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ìœ¼ë¡œ êµ¬ì„±
- ë½ íšë“ ìˆœì„œ í†µì¼: ticketType ë½ â†’ DB ì‘ì—… ìˆœì„œ ê³ ì •

### ì£¼ì˜í•  ì 
- ë½ì€ íšë“í•˜ëŠ” ìˆœì„œì™€ ìœ„ì¹˜ê°€ í•µì‹¬
- ë¶„ì‚°ë½ + ë¹„ê´€ë½ ì¡°í•© ì‹œ íŠ¸ëœì­ì…˜ ê²½ê³„ ì¤‘ìš”
- ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì•„ë‹ˆë¼ ì„œë¹„ìŠ¤ ë‚´ì—ì„œ ë½ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì²˜ë¦¬í•´ì•¼ ì•ˆì •ì 

___

## í…ŒìŠ¤íŠ¸ ì½”ë“œ

```java
@SpringBootTest
@Activate("test")
public class TicketPurchaseLockTest {
	private static final int CONCURRENT_USERS = 100; // ë™ì‹œ ì ‘ì†ì ìˆ˜ 
	private static final Long TICKET_STOCK = 50L; // í‹°ì¼“ ì¬ê³ 
	private Long ticketTypeId;
	private List<Long> ids; // ìœ ì €Id ì €ì¥ ë¦¬ìŠ¤íŠ¸

	@BeforeEach
	void setUp(){
		paymentRepository.deleteAllInBatch();
		ticketRepository.deleteAllInBatch();  
		memberRepository.deleteAllInBatch();  
		eventItemRepository.deleteAllInBatch();  
  
		ids = setupTestData();  
		ticketTypeId = setupTicketType();
	}

	@Test
	void concurrentTest_PessimisticLock() throws InterruptedException{
		//given
		ExecutorService executorService = Executors.newFixedThreadPool(CONCURRENT_USERS)
		CountDownLatch startLatch = new CountDownLatch(1);
		CountDownLatch finishLatch = new CountDownLatch(CONCURRENT_USERS);

		for(int i = 0; i < CONCURRENT_USERS; i++){
			final int index = i;
			executors.submit(() -> {
				try{
					startLatch.await();
					Long memberId = ids.get(index);
					 PaymentMessage message = PaymentMessage.builder()  
                        .ticketTypeId(ticketTypeId)  
                        .memberId(memberId)  
                        .amount(10000)  
                        .paymentKey("payment-key")  
                        .orderId("orderId" + memberId)  
                        .approvedAt(LocalDateTime.now())  
                        .requestedAt(LocalDateTime.now())  
                        .build();  
  
                paymentService.saveTicketAndPayment(message);  
            }catch (InterruptedException e){  
                e.getStackTrace();  
            }finally {  
                finishLatch.countDown(); // ì‘ì—… ì™„ë£Œ  
            }  
        });  
    }  
    //when  
    startLatch.countDown(); // ìŠ¤ë ˆë“œ ì‹œì‘  
    finishLatch.await(20, TimeUnit.SECONDS); // ì¢…ë£Œ ëŒ€ê¸°  
    executorService.shutdown(); // ì¢…ë£Œ  
  
    //then  
    TicketType result = ticketTypeRepository.findById(ticketTypeId).orElseThrow();  
    List<Ticket> tickets = ticketRepository.findAll();  
  
    Assertions.assertEquals(result.getIssuedQuantity(),TICKET_STOCK);  
    Assertions.assertEquals(tickets.size(),TICKET_STOCK);  
}  
  
@Test  
@DisplayName("100ëª…ì´ ë™ì‹œì— í‹°ì¼“ êµ¬ë§¤ ìš”ì²­ ì‹œ ë ˆë””ìŠ¤ ë½ ìˆ˜í–‰")  
void concurrentTest_redisLock() throws Exception {  
    //given  
    ExecutorService executorService = Executors.newFixedThreadPool(CONCURRENT_USERS);  
    CountDownLatch startLatch = new CountDownLatch(1);  
    CountDownLatch finishLatch = new CountDownLatch(CONCURRENT_USERS);  
  
    for(int i = 0; i < CONCURRENT_USERS; i++){  
        final int index = i;  
        executorService.submit(() -> {  
            try {  
                startLatch.await();  
                Long memberId = ids.get(index);  
                PaymentMessage message = PaymentMessage.builder()  
                        .ticketTypeId(ticketTypeId + index)  
                        .memberId(memberId)  
                        .amount(10000)  
                        .paymentKey("payment-key")  
                        .orderId("orderId" + memberId)  
                        .approvedAt(LocalDateTime.now())  
                        .requestedAt(LocalDateTime.now())  
                        .build();  
                paymentService.saveTicketAndPayment(message);  
            }catch (InterruptedException e){  
                e.getStackTrace();  
            }finally {  
                finishLatch.countDown();  
            }  
        });  
    }  
    //when  
    startLatch.countDown();  
    finishLatch.await(20,TimeUnit.SECONDS);  
    executorService.shutdown();  
  
    //then  
    TicketType ticketType = ticketTypeRepository.findById(ticketTypeId).orElseThrow();  
    List<Ticket> tickets = ticketRepository.findAll();  
  
    Assertions.assertEquals(ticketType.getIssuedQuantity(),TICKET_STOCK);  
    Assertions.assertEquals(tickets.size(),TICKET_STOCK);  
  
}
				}
			})
		}
	}
}
```
- ìœ„ì˜ í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí•œ ì´í›„ì—ëŠ” db ì•ˆì— ë°ì´í„°ë“¤ì´ ì‚¬ë¼ì§€ì§€ ì•Šì•„ì„œ yml ì—ì„œ create-drop ì„ ì–´í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ì´ˆê¸°í™”í•´ì¤„ ìˆ˜ ìˆë„ë¡ í•œë‹¤.