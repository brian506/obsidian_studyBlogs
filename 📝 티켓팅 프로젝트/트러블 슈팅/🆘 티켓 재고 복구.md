
## 어떤 상황이었나?

만료된 티켓 자동 취소 스케줄러와 사용자 결제 처리가 동시에 동작하는 환경에서 문제 발생
- 트래픽이 몰리는 환경에서 새로운 티켓이 유입되고 결제 완료 로직을 처리하는 도중에 스케줄러가 실행될 때마다, 응답 지연이 0.1s 미만에서 2.5s 까지 급증하는 현상 발생
- DB 커넥션이 고갈되고 처리량 또한 급감함
![](../../images/스크린샷%202026-02-15%2012.50.20.png)

## 그게 왜 문제였나?

잘못된 트랜잭션 범위와 인덱스 락 경합이 복합적으로 작용한 구조적 문제였음

**원인 1 ) 트랜잭션 범위 설정 오류**
- 스케줄러 로직의 트랜잭션 안에서 레디스 네트워크 통신과 DB 조회, 쓰기를 한번에 처리하고 있어서 DB 커넥션을 오랫동안 점유하고 있었음
- 이로 인해 다른 DB 로직들이 커넥션을 얻지 못하고 대기하게 됨

**원인 2) 인덱스 구조에 따른 데드락**
- [status,expiredAt] 복합 인덱스를 적용했으나, 스케줄러의 대량 업데이트와 사용자의 결제 승인 업데이트가 충돌
- **스케줄러** : PENDING 상태의 티켓들을 범위로 LOCK (Gap Lock)
- **결제 트랜잭션** : 특정 티켓을 PENDING -> CONFIRMED 로 변경 시도 (이는 인덱스 내에서 PENDING인 상태의 티켓을 DELETE 하고 CONFIRMED 인덱스 구역으로 INSERT 하는 과정임)
- 스케줄러가 잠가둔 범위내에서 결제 트랜잭션이 인덱스 이동을 시도하다가 데드락 발생
![](../../images/스크린샷%202026-02-15%2012.59.10.png)
## 무슨 방식을 채택했나? 그 근거는?

- **방식:**
    - 티켓 오픈 직후 등 트래픽 피크 타임(예: 1시간)에는 **스케줄러 작동을 중지**.    
    - 트래픽이 적은 시간대(새벽 등)에 만료된 티켓을 일괄 처리하는 **배치(Batch) 시스템**으로 전환.    
    - (기술적 선행 작업: 트랜잭션 범위를 `조회(No-Tx) → 외부 통신 → 쓰기(Tx)`로 분리하여 커넥션 점유 최소화 완료).
        
- **근거:**    
    1. **데드락의 구조적 필연성:** `Bulk Update`와 `Single Update`가 동일 인덱스 테이블에서 경합하는 한, 기술적 튜닝(Lock Hint 등)만으로는 데드락을 100% 막을 수 없음.        
    2. **서비스 안정성 최우선:** 예매 시스템의 핵심 가치는 "사용자가 오류 없이 결제하는 것"임. 만료 처리는 실시간성이 상대적으로 덜 중요함.        
    3. **리소스 집중:** 피크 타임의 DB 리소스를 100% 결제 트랜잭션 처리에 집중시켜 TPS를 극대화.

## 왜 다른 방법은 안되나?

- **대안 1: 인덱스 제거 (No Index)**    
    - 이유: `UPDATE` 시 **Full Table Scan**이 발생하여 테이블 전체에 락(Lock)이 걸림. 데드락을 피하려다 서비스 전체가 마비(All Stop)되는 더 큰 장애 초래.        
- **대안 2: 기술적 회피 (Skip Locked 등)** 
    - 이유 `SKIP LOCKED`를 사용하면 데드락은 피할 수 있지만, 데이터 누락 가능성이 있고 근본적인 DB 부하(CPU/Disk I/O) 문제는 해결되지 않음.        
- **대안 3: 단순 쿼리 튜닝**    
    - 이유: 문제의 본질이 쿼리 속도가 아니라 **락(Lock)의 종류(Gap vs Record)와 획득 순서**에 있었기 때문에 효과 없음.

## 어떻게 검증했나?

- **도구:** k6 (부하 테스트), Grafana (모니터링), MySQL Logs (`SHOW ENGINE INNODB STATUS`).    
- **검증 과정 & 증거 자료:**
    
    1. **현상 파악:** Grafana Latency 그래프에서 스케줄러 실행 시점의 **2.5s 스파이크** 캡처.
        
    2. **원인 규명 1:** `EXPLAIN` 실행 계획을 통해 인덱스 부재 시 **Type: ALL(Full Scan)** 확인.
        
    3. **원인 규명 2:** `InnoDB Status` 로그에서 `LATEST DETECTED DEADLOCK`을 확보하여 **Gap Lock**과 **Insert Intention Lock**의 충돌 확인.
        
    4. **최종 확인:** 정책 변경(스케줄러 중지) 후 부하 테스트 시 **Zero Deadlock** 및 안정적인 TPS/Latency 그래프 확보.

## 회고

- **배운 점 (Learnings):**    
    - **DB의 내부 동작:** `UPDATE`가 인덱스에서는 단순 값 변경이 아니라 **위치 이동(Delete+Insert)**임을 이해하고, 이로 인해 `Gap Lock`과 충돌할 수 있음을 깊이 있게 학습함.        
    - **트랜잭션 관리:** `@Transactional`의 범위를 무심코 설정하면 외부 통신(Redis 등) 시 치명적인 DB 병목을 유발한다는 것을 체감함.        
    - **엔지니어링의 시야:** 무조건 코드로 해결하려는 것보다, **비즈니스 프로세스를 재설계하는 것이 가장 효율적이고 안전한 아키텍처**가 될 수 있음을 깨달음.        
- **아쉬운 점 & 향후 계획:**    
    - 초기 설계 단계에서 대량 처리(Batch)와 실시간 처리(OLTP)의 충돌 가능성을 미리 예측하지 못한 점.       
    - 향후에는 Redis의 TTL(Time-To-Live) Event 등을 활용해 DB 부하 없이 만료 처리를 트리거하는 방식도 고려해볼 예정.

## 참고

[스토리지 엔진 수준의 락 (레코드 락, 갭 락, 넥스트 키 락)](../../CS%20공부/데이터베이스/트랜잭션/스토리지%20엔진%20수준의%20락%20(레코드%20락,%20갭%20락,%20넥스트%20키%20락).md)
