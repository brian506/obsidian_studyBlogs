## 어떤 상황이었나?

사용자가 티켓을 선택하고 (결제 상태는 PENDING), PG 결제 단계에서 취소하거나 네트워크 문제로 해당 티켓이 결제가 완료되지 않는 상황이 발생함

## 그게 왜 문제였나?

1. **재고 불일치** : 사용자가 결제를 하지 않았지만, 앞서 티켓 요청에서 재고 차감이 되었기 때문에 티켓 수가 영구적으로 차감된 상태로 남아있음

2. **동시 쓰기 이슈** : 이를 해결하기 위해 스케줄러로 (PENDING, 유효기간 < 현재 시간) 인 상태의 티켓을 분 단위별로 조회해서 수정하려고 했으나, 트래픽이 몰리는 상황에서 스케줄러가 DB에 과부하를 주거나, TIcket 테이블에서 `UPDATE`를 하려면 테이블 전체를 훑어야 하는데,  사용자가 티켓을 요청했을 때 생성되는 `INSERT` 쿼리 때문에 테이블 전체를 훑을 때 락이 걸려서 `INSERT`쿼리는 대기해야함

3. **데드락 위험** : 동시에 조회를 했을 때 영향이 없으면 공유략을 써도 되지만, 동시에 쓰기 연산을 하게 되면 배타락을 써야함. 어떤 락을 써야 할지 불분명하여 공유락을 썼을 떈 데드락 발생 가능성이 있었음


## 무슨 방식을 채택했나 그 근거는?

-  **스케줄러 + 인덱스 기반의 만료 처리** : 스프링 스케줄러로 `expiredAt` 이 지난 `PENDING` 티켓을 조회하여 취소 처리 및 재고 복구(`issuedQuantity + 1`), 조회할 때 (status, expiredAt)의 복합인덱스를 적용
	- **근거** : 인덱스를 활용하면 Ticket 엔티티를 조회할 때 Full table scan 을 하지 않고, 만료된 데이터만 접근하게 됨. 이는 스캔 과정에서 불필요한 행이나 간격에 락을 거는 것을 방지하여, 다른 유저들의 `INSERT` 를 블로킹하지 않음

- **비관적 락(`PESSIMISTIC_WRITE`) 적용** : 재고 조회 차감 시 배타적 락(X-Lock) 사용
	- **근거** : 공유 락을 사용할 경우, 두 트랜잭션이 서로 공유 락을 쥔 상태에서 쓰기 락으로 업그레이드 할 떄 데드락 발생함. 조회 시점부터 락을 걸어야 정합성과 에러 방지에 적합함

## 왜 다른 방법은 안되나?

- **Redis TTL (Key Space Notification):**
    - Redis 이벤트는 'Fire-and-Forget' 방식이라, 서버가 순간적으로 다운되거나 네트워크 이슈가 생기면 이벤트가 유실될 수 있음. 재고는 데이터 정합성이 생명인 만큼, 유실 가능성이 있는 방식보다는 DB 기반의 스케줄러가 더 확실함 (Reliability).
        
- **인덱스 없는 스케줄러 실행:**
    - InnoDB는 `UPDATE`를 위한 조회 시 스캔하는 모든 행에 락을 검. 인덱스가 없으면 테이블 전체를 잠그게 되어, 티켓팅 피크 타임에 모든 유저의 구매 요청이 대기(Blocking)하거나 타임아웃 발생하는 참사가 일어남.
        
- **PESSIMISTIC_READ (공유 락):**
    - 단순 조회에는 좋지만, '조회 후 수정'이 일어나는 재고 차감 로직에서는 데드락의 주범이 됨.

## 어떻게 검증했나?





## 회고 (무엇을 배웠나, 아쉬운 점)

- **배운 점:**    
    - 단순히 '쿼리가 빠르다/느리다'가 아니라, **'쿼리가 락을 어디까지 거느냐'** 가 동시성 처리의 핵심임을 깨달음.        
    - `UPDATE`를 위한 `SELECT`는 단순 조회와 달리 배타적 락을 건다는 점, 그리고 인덱스가 없으면 테이블 전체가 잠길 수 있다는 점을 배움.        
    - 공유 락(S-Lock)이 수정 작업과 만났을 때 데드락을 유발하는 과정을 이해함.    

- **아쉬운 점 / 향후 과제:**    
    - 현재 대기열 유입을 보수적으로 100명으로 잡았는데, 최적화된 로직을 바탕으로 부하 테스트를 수행하여 실제 한계 TPS까지 유입량을 늘려보는 튜닝이 필요함.