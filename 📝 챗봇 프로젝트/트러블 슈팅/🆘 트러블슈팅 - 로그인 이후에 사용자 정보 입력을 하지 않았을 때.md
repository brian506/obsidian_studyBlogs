#트러블슈팅 #queryDSL
# 개요
사용자가 로그인을 성공하면 DB 에 바로 저장된다.  
하지만 사용자가 로그인을 했지만 사용자 정보 입력을 하지 않았을 때 DB 에 로그인 정보가 남아있게 되면 불필요한 로그인 정보와 데이터 불일치가 일어날 수 있다.
로그인은 Auth-service, 사용자 정보 입력은 Chat-service 에서 독립된 서로 다른 서비스에서 동작한다.
트랜잭션의 원자성을 보장하기 위해서 **보상 트랜잭션**을 적용하여 이를 해결하고자 한다.

MSA 아키텍처에서는 분산된 트랜잭션의 원자성을 보장하기 위해서 보통 SAGA 패턴의 choreography 이용한다.
choreography은 메시징 큐를 이용해서 pub/sub 방식으로 서로의 상태를 공유하며 실시간으로 보상 트랜잭션을 적용할 수 있다.
choreography 을 이용했을 때 서비스간의 결합도가 낮아지고, 한 서비스가 장애가 발생해도 전체 서비스가 장애가 발생하지 않는 독립성을 갖는다는 이점이 있다.
하지만 메시징큐를 이용할 때 발생하는 비용을 생각해야한다. 그리고 choreography으로 이익을 극대화하려면 서비스들의 수가 많아야 의미가 있다.

현재 두 서비스 간의 원자성을 보장하기 위함으로 다른 방안으로는 chat -> auth 로 API 호출을 통하여 서로의 상태 변경을 각 DB 에서 조회한 후 상태변경을 통해서 **보상 트랜잭션** 을 적용하는 것이다.
하지만 API 호출로 이를 해결하게 되면 상대적으로 서비스 간의 결합도는 높아지고, 동기 방식이라 요청/응답 속도가 느리게 된다.
이를 보완하기 위해 
1. 로그인 시 auth 정보에 PENDING 으로 상태 저장, expiredAt으로 유효시간 설정
2. chat 에서 사용자 정보 입력이 완료되면 Set 에 저장 후 완료된 사용자들을 갖고 auth 경로로 스케줄러를 이용해서 하루에 한번 요청
3. auth 에서 받아서 PENDING -> ACTIVE 로 변경
4. auth 에서 유효시간이 지난 사용자 스케줄러를 이용해서 삭제

## 구현

### 1. 사용자 로그인 시 상태 저장
```java
@Column(name = "expired_at")  
private LocalDateTime expiredAt;  
  
public static User saveUser(GoogleUserResponse response){  
    return User.builder()  
            .email(response.email())  
            .role(Role.GENERAL)  
            .username(response.name())  
            .status(LoginStatus.PENDING)  
            .expiredAt(LocalDateTime.now().plusMinutes(10)) // 10분 안에 사용자 정보 입력 성공 만료 시간  
            .build();  
}
```
- 만료시간 : 로그인 이후 30분 유효

### 2. Chat 서비스에서 사용자 입력 정보 완료된 사용자 Set 에 담아서 Auth 로 API 호출
```java
public class CompletedUserService {  
  
    private final Set<UUID> completedUserIds = ConcurrentHashMap.newKeySet();  
    private final RestClient restClient;  
    private final String AUTH_ENDPOINT = "/users/batch-status";  
  
    @Value("${auth-service.url}")  
    private String authURL;  
  
    // 사용자 정보입력 완료시 set 에 사용자 추가  
    public void addUserAsCompleted(String userId) {  
        completedUserIds.add(UUID.fromString(userId));  
    }  
  
    // 하루마다 auth 서비스로 전달  
    @Scheduled(fixedDelay = 6000) //60000 * 60 * 24  
    public void sendBatchUpdateToAuthService() {  
        if (completedUserIds.isEmpty()) {  
            return;  
        }  
        restClient.patch()  
                .uri(authURL + AUTH_ENDPOINT)  
                .contentType(MediaType.APPLICATION_JSON)  
                .body(completedUserIds)  
                .retrieve()  
                .toBodilessEntity();  
  
    }  
}
```
- restClient 이용해서 patch 로 UserStatus 만 변경 요청

### Auth-Service 에서 응답 받고 상태 변경
```java
// UserController....

@PatchMapping("/batch-status")  
public ResponseEntity<?> activateUsersBatch(@RequestBody List<UUID> userIds){  
    userService.activateUsersBatch(userIds);  
    SuccessResponse response = new SuccessResponse(true,"사용자 상태 변경 성공",null);  
    return new ResponseEntity<>(response, HttpStatus.OK);  
}

// UserService ....

    // PENDING -> ACTIVE 로 변경 배치 활성화  
    public void activateUsersBatch(List<UUID> userIds){  
        if(userIds.isEmpty() || userIds == null){  
            throw new DataNotFoundException("배치할 사용자가 없습니다.");  
        }  
        try{  
            long updatedCount = userRepository.activatePendingUsers(  
                    userIds,  
                    LoginStatus.ACTIVE,  
                    LoginStatus.PENDING  
            );  
            log.info("배치 활성화 완료. {}명의 사용자 상태를 ACTIVE 로 업데이트",updatedCount);  
            if(updatedCount != userIds.size()){  
                throw new DataIncorrectException("모든 사용자의 배치가 완료되지 않았습니다.");  
            }  
        } catch (Exception e){  
            log.warn("배치 실패");  
        }  
    }  
  
    // 유효시간이 지난 사용자 삭제  
    public void deleteExpiredUsers(){  
        List<User> expired = userRepository.findExpiredPendingUsers(LocalDateTime.now());  
        if(!expired.isEmpty()){  
            userRepository.deleteAll(expired);  
        }  
    }

// UserRepository ...(QueryDSL)

@Override  
public long activatePendingUsers(List<UUID> userIds, LoginStatus newStatus, LoginStatus curStatus) {  
    return query  
            .update(user)  
            .set(user.status,newStatus)  
            .setNull(user.expiredAt)  
            .where(  
                    user.id.in(userIds),  
                    user.status.eq(curStatus)  
            )  
            .execute();  
}  
@Override  
public List<User> findExpiredPendingUsers(LocalDateTime now) {  
    return query  
            .selectFrom(user)  
            .where(  
                    user.status.eq(LoginStatus.PENDING),  
                    user.expiredAt.lt(now) // less than  
            )  
            .fetch();  
}

// UserCleanupScheduler ...

@Scheduled(cron = "0 0 23 * * *")  
public void runCleanJob(){  
    userService.deleteExpiredUsers();  
    log.info("PENDING 상태의 사용자 삭제 완료");  
}

```

> `activatePendingUsers()`
   - User 의 status (curStatus -> newStatus)
   - 원래 설정되어있던 expiredAt -> NULL 로 변경

> `findExpiredPendingUsers`
- 현재시간보다 유효시간이 큰 값인 user 삭제
___
이렇게 스케줄러를 이용해서 사용자가 로그인했을 때마다 API 호출을 하는 것이 아닌 하루에 한번 등 일정 주기를 정하고 User 의 DB에 UPDATE 쿼리를 수행함으로써 많은 지연도 일어나지 않고 DB에 부하를 가하지도 않을 뿐더러 비용적인 측면에서 이점을 볼 수 있다.