## Zookeeper

분산 아키텍처로서 Kafka 클러스터는 단일 머신으로 구성되기 보다 여러 머신을 붙여서 사용하는 것이 바람직하다.
이때 분산 환경을 관리하는 플랫폼인 Apache Zookeeper 가 쓰인다.

Zookeeper 는 분산 시스템의 일부분이기 때문에 동작을 멈춘다면 분산 시스템이 멈출수도 있다. 그래서 안정성을 확보하기 위해 클러스터로 구축한다.

클러스터는 **홀수로** 구축한다.
어떤 서버에 문제가 생겼을 경우, 과반수 이상의 데이터를 기준으로 일관성을 맞춘다.
살아있는 노드가 과반수 이상이면 지속적인 서비스를 제공한다.

이제 Kafka 클러스터와 Zookeeper 가 어떻게 연동되는지 살펴보자.
Zookeeper 는 Kafka 클러스터의 구성 정보, 브로커 상태, Topic 파티션 배치 등을 관리한다. 
브로커는 Zookeeper에 자신의 상태를 등록하고,
클러스터의 모든 브로커 간의 정보를 공유하여 클러스터를 관리한다.
###  ✅ 1. 클러스터 메타데이터 관리

Zookeeper 는 클러스터의 구성 정보를 저장하고 관리한다.
클러스터에 속한 브로커들의 정보, Topic 의 파티션 정보, Topic 의 구성 설정 등의 메타 데이터를 저장하여 클러스터의 상태를 유지한다.

### ✅ 2. 리더 선출

Kafka Topic 의 파티션은 여러 개의 브로커에 복제될 수 있다. 
Zookeeper 는 파티션의 리더를 선출하고, 해당 파티션의 리더와 팔로워 간의 동기화를 관리한다.

### ✅ 3. 브로커 상태 관리

브로커는 Zookeeper에 자신의 상태를 등록한다. 이를 통해 브로커의 살아있음 상태와 연결된 Topic 파티션들의 리더와 팔로워 상태를 지속적으로 감시한다.

### ✅ 4. 동적 Topic 파티션 관리

Kafka의 Topic 파티션 수를 동적으로 조절할 수 있다.
Zookeeper 를 통해 파티션 수를 변경하면 클러스터에서 해당 파티션들을 적절히 재배치한다.

### ✅ 5. 클러스터 리더 인식

Kafka 클러스터에서 리더가 변경되거나, 브로커가 추가/삭제되면 해당 정보를 Zookeeper 를 통해 클러스터의 모든 브로커에 전달하여 업데이트한다.

## KRaft

KRaft 모드를 사용하면 Zookeeper 없이도 Kafka를 운영할 수 있다.
외부 Zookeeper 와의 통신이 아닌, 브로커의 일부가 컨트롤러의 역할을 수행하면서 Zookeeper 를 대체한다.

즉, 모든 Kafka 클러스터의 **메타데이터는 Kafka 토픽에 직접 저장이 되어서 내부적**으로 관리된다.
KRaft는 Zookeeper 와 마찬가지로 메타데이터인 토픽 이름, 파티션 개수 등으로 읽고 쓰고 동가화 과정을 거친다.

![](../../images/스크린샷%202026-02-13%2015.06.17.png)

- **클라이언트** : Kafka 클러스터와 상호작용하는 외부 애플리케이션으로, 프로듀서(메시지 발행), 컨슈머(메시지 구독), 관리 도구 등이 포함된다. 
- **메타데이터 로그** : Kafka 클러스터의 상태와 구성 정보를 저장하는 핵심 데이터 구조로, 브로커 목록, 토픽 구성, 파티션 할당 등의 정보를 시간 순서대로 기록하고 관리한다.
- **리더** : 메타데이터 변경 요청을 처리하고, 변경 사항을 로그에 기록하며 voter들에게 전파하는 주체이다.
- **보터(Voter)** : 컨트롤러의 변경사항을 검증하고 승인하며, 컨트롤러 실패 시 새로운 컨트롤러 선출에 참여한다. (일관성 유지 목적)
- **옵저버(Observer)** : 읽기 전용 노드이고 커밋된 변경사항을 동기화하고 클라이언트의 읽기 요청을 처리한다.

### KRaft 내부 요소 간의 처리 과정
KRaft 내에서 리더, 보터, 옵저버는 메타데이터를 통해서 읽고, 쓰고, 동기화 과정을 거친다.

#### 메타데이터 쓰기 과정
1. 클라이언트가 메타데이터 변경 요청을 리더에게 전송한다.
2. 리더는 변경 사항을 메타데이터 로그에 기록하고 보터들에게 전파한다.
3. 과반수의 보터로부터 확인을 받으면 변경사항을 커밋한다.
4. 커밋된 변경사항을 옵저버들에게도 전파하여 동기화한다.

#### 메타데이터 읽기 과정
1. 클라이언트는 컨트롤러, 보터, 옵저버 중 어느 노드에서든 읽기 가능하다.
2. 읽기 요청은 해당 노드의 로컬 상태에서 직접 처리를 한다.

#### 동기화 과정
1. 리더는 주기적으로 현재 커밋된 로그 위치를 보터와 옵저버에게 알린다.
2. 보터와 옵저버는 자신의 로그를 컨트롤러의 상태와 동기화한다.
3. 누락된 로그 엔트리가 있다면 컨트롤러에게 요청하여 복구한다.

#### 장애 복구 과정
1. 리더 실패 시 보터들간의 선거를 통해 새로운 리더를 선출한다.
2. 새 리더는 과반수의 보터로부터 최신 상태를 확인하고 복구한다.
