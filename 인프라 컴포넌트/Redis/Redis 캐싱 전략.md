#캐싱

Redis 는 원격에 위치하고 프로세스로 존재하는 In-Memory 기반의 Dictionary(key-value) 구조 데이터 관리 Server 시스템이다.

**특징**
- 메모리 기반이라 모든 데이터들을 메모리에 저장하고 조회가 매우 빠르다 (MySQL 보다 10배 정도 빠름)
- 서비스의 상황에 따라 DB로 사용하거나, 캐시로도 사용한다.
- **원격 데이터 저장소**로 여러 서버에서 **같은 데이터를 공유**하고 보고 싶을 때 사용할 수 있다.
- 다양한 자료구조를 지원한다. (Strings, Set, Sorted-Set, Hashes, List ...)
- 쓰기 성능 증대를 위한 클라이언트측 샤딩을 지원한다.
- 메모리 기반이지만 **영속적인 데이터 보존**이 가능하다.
- 스냅샷 기능을 제공해 메모리 내용을 `*.rdb` 파일로 저장하여 해당 시점으로 복구할 수 있다.
- 여러 프로세스에서 동시에 같은 Key에 대한 갱신을 요청하는 경우, 동시성 제어를 위한 Atomic 한 처리가 가능하다. - [Redis 에서 동시성을 제어하는 방법](../../CS%20공부/데이터베이스/동시성%20제어/Redis%20에서%20동시성을%20제어하는%20방법.md)
- 기본적으로 1개의 싱글 스레드로 수행되므로, 안정적인 인프라를 구축하기 위해서는 Master-Slave 구조가 필수적이다.


## Redis - 캐시 전략

**cache hit** : 캐시 스토어(ex : Redis)에 데이터가 있을 경우 바로 가져옴 (빠름)
**cache miss** : 캐시 스토어에 데이터가 없을 경우 어쩔 수 없이 DB에서 가져옴 (느림)

캐시를 이용하게 되면 **데이터 정합성 문제**가 발생할 수 있다.
DB에서 조회하는 것과 캐시 스토어에서 조회하는 데이터값이 다른 현상이 발생할 수 있기 때문에 
**캐시 읽기 전략(Read Cache Strategy)** 와 **캐시 쓰기 전략(Write Cache Strategy)** 을 통해 데이터 정합성 문제를 해결하면서 빠른 성능을 가질 수 있게 설계해야한다.

## 캐시 읽기 전략 (Read Cache Strategy)

### Look Aside 패턴 (= Cache Aside)
: 데이터를 찾을 때 캐시에 저장된 데이터가 있는 지 우선적으로 조회하는 전략이다. 만약에 없으면 DB에서 조회한다.

**특징**
- **반복적인 읽기**가 많은 호출에 적합
- 캐시와 DB가 분리되어 있기 때문에 **원하는 데이터만** 별도로 구성하여 캐시에 저장하고 캐시 **장애 대비 가능**

**캐시 동작 순서**
1. 캐시 스토어에 검색하는 데이터가 있는 지 확인 (cache hit)
2. 캐시 스토어에 없을 경우 DB에서 데이터 조회 (cache miss)
3. DB에서 조회해온 데이터를 캐시 스토어에 업데이트

**주의 사항**
- 이 방식은 **캐시에 장애가 발생해도** DB에 요청하여 **서비스 문제는 대비**할 수 있지만, 캐시 스토어와 DB간 **정합성 문제**가 발생할 수 있다.
- **초기 조회 시 무조건 DB를 호출**해야 하므로 **단건 호출 빈도가 높은** 서비스에선 적합하지 않다.
- 반복적으로 동일한 쿼리를 수행하는 서비스에 적합하다.

> Cache Warming
> 미리 Cache에 데이터를 밀어 넣어두는 작업
> Cache miss가 다량 발생하지 않도록 하기 위함이다.

### Read Through 패턴
: 데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임하여 데이터를 조회하는 방식이다.

**특징**
- DB에서 데이터를 항상 가져오기 때문에 전체적으로 속도가 느림
- 데이터 조회를 전적으로 캐시에만 의존하므로, **장애 대비가 안됨**
- **캐시와 DB간의 데이터 동기화가 항상 이루어져 있어서 데이터 정합성 문제가 발생하지 않음**

**캐시 동작 순서**
1. 캐시 스토어에 검색하는 데이터가 있는지 확인 (cache hit)
2. 캐시 스토어에 없을 경우 캐시에서 DB에 데이터를 조회하여 자체 업데이트 (cache miss)
3. 캐시에서 데이터 가져옴

#### Look Aside 방식과 다른점
캐시 스토어에 저장하는 주체가 서버인지 DB인지에 따른 차이점이 있다.
`Look Aside` 는 **서버가 DB에서 조회하지만**,
`Read Through`는 **캐시가 DB를 조회한다**.

**주의 사항**
- 데이터베이스 접근을 최소화할 수 있다.
- 캐시에서 DB를 조회하기 때문에, 캐시가 장애가 발생하면 시스템 전체가 오류가 생긴다. 따라서 **Replication 또는 Cluster**로 구성하여 가용성을 높여야 한다.

## 캐시 쓰기 전략 (Write Cache Strategy)

### Write Back 패턴 (= Write Behind)
: 데이터를 저장할 때 DB에 바로 쿼리하지 않고, 캐시에 모아서 배치 작업을 통해 DB에 반영하는 방식이다.

**특징**
- 한번에 쓰기 작업을 하기 때문에 쿼리 비용과 부하를 줄일 수 있음
- 데이터 정합성 확보
- 자주 사용되지 않는 불필요한 리소스 저장
- 캐시에서 오류가 발생하면 데이터를 영구적으로 소실함

**캐시 동작 순서**
1. 모든 데이터를 캐시 스토어에 저장
2. 일정 시간이 지난 뒤 DB에 저장

**주의 사항**
- 캐시에 장애가 발생하면 캐시에 입력되어 있던 쓰기 데이터들이 유실될 수 있다.
- 마찬가지로 **Replication 또는 Cluster** 구조로 캐시 서비스의 가용성을 높여야 한다.


### Write Through 패턴
: DB와 캐시 동시에 데이터를 저장하는 전략

**특징** 
- 데이터를 저장할 때 **먼저 캐시에 저장하고 나서 바로 DB에 저장**
- Read Through 와 마찬가지로 DB 동기화 과정을 캐시에게 위임
- DB와 캐시가 항상 동기화 되어 있어, **캐시의 데이터는 항상 최신 상태로 유지**
- 캐시와 백업 저장소에 업데이트를 같이 하여 데이터 일관성을 유지할 수 있으므로 안정적
- **데이터 유실이 발생하면 안되는 상황에 적합**
- 자주 사용되지 않는 **불필요한 리소스 저장**
- 매 요청마다 **두번의 쓰기 작업이 발생**하여 빈번한 쓰기 작업이 많은 서비스에서는 성능 이슈 발생

**캐시 동작 순서**
1. DB에 저장할 데이터가 있으면 우선 캐시 스토어에 저장
2. 그리고 캐시 스토어가 DB로 바로 저장

> Write Back, Write Through 모두 자주 사용되지 않는 데이터가 저장되어 리소스 낭비가 발생한다.
> 따라서 TTL(유효시간)을 사용하여 데이터를 삭제해줘야 한다.


### Write Around 패턴
: 쓰기 작업시 캐시 스토어를 건드리지 않고 오직 DB에만 저장하는 방식

**특징**
- Cache miss 가 발생하는 경우에만 DB와 캐시에도 데이터를 저장
- 캐시와 DB간의 데이터가 다를 수 있음
- DB에서 수정,삭제가 일어날때마다 별도로 캐시 스토어 데이터도 수정, 삭제해야한다.

> Write Around 패턴은 주로 Look Aside, Read Through 패턴과 결합해서 사용된다.
> 데이터가 한 번 쓰여지고 + 조회가 빈번하지 않는 상황


## 캐시 읽기 + 쓰기 전략 조합

### Look Aside + Write Around 

![](../../images/스크린샷%202026-02-08%2021.02.14.png)

- 가장 흔하고 많이 쓰임

### Read Through + Write Around 

![](../../images/스크린샷%202026-02-08%2021.03.01.png)

- 쓰기는 항상 DB에서, 읽기도 항상 DB에서 읽어오기 때문에 데이터 정합성 이슈는 완벽 차단

### Read Through + Write Through

![](../../images/스크린샷%202026-02-08%2021.04.45.png)

- 데이터를 쓸 때 항상 캐시에 먼저 쓰므로, 읽어올 때 최신 캐시 데이터 보장
- 데이터를 쓸 때 항상 캐시에서 DB로 