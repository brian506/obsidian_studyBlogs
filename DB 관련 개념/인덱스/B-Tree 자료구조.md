#database 

# 개요
**RDBMS 에서는 B+Tree** 를 완전하게 사용하는 반면에 **MongoDB 는 변형된 B-Tree** 를 사용한다.

MongoDB 는 **리프노드에만 데이터가 저장(B+Tree 특징)** 되지만 **리프 노드 간 연결 리스트는 없다.(B-Tree)**


## B-Tree

B-Tree 는 이진트리를 확장한 형태이다.
이진트리 중에서 각 노드의 *왼쪽 서브트리에는 해당 노드보다 작은 값의 노드*들이, *오른쪽 서브트리에는 해당 노드보다 큰 값의 노드*들이 위치하도록 정렬한 이진트리를 **이진 탐색 트리**라고 한다.

**이진 탐색 트리 구조**
![사진](tree.png)

**3차 B-Tree 구조**
아래와 같이 3차 B-Tree 는 아래와 같이 최대 3개의 자식을 가질 수 있다.
![사진](b-tree.png)
**탐색 순서**
key : `14`를 찾는다고 가정
1. 7 < `14` < 15 이므로 사이에 있는 포인터가 가리키는 자식노드로 이동
2. 9 < 11 < `14` 이므로 오른쪽에 있는 포인터로 이동
3. `14`를 찾았으므로 반환
key : `14 ~20 `찾는다고 가정
- B-Tree 는 인접 노드에 해당 key 가 있는 지 모르기 때문에 **루트 노드를 계속 왔다갔다 해야됨**
- 


**특징** 
- 루트노드에서부터 리프노드까지의 길이는 항상 같음 - > 데이터 조회 속도 일정
- 노드 하나에 여러개의 데이터(key)와 자식 노드 포인터 보유
- 각 노드 내의 데이터들은 항상 정렬된 상태
- 모든 노드에 Key 와 Data 함께 저장
- 한 노드는 최대 m-1 개의 키를 가질 수 있음(m : 차수)
## B+Tree

![사진](b+.png)
**탐색 순서**
key : `14`를 찾는다고 가정
1. 7 < `14` < 15 이므로 사이에 있는 포인터가 가리키는 자식노드로 이동
2. 9 < 11 < `14` 이므로 오른쪽에 있는 포인터로 이동
3. `14`를 찾았으므로 반환
key : `14 ~20 `찾는다고 가정
- B+Tree 는 인접 노드끼리 연결되어 있으므로 **연결 리스트를 따라 순차적으로 조회 가능**
- 루트 노드까지 가지 않고 리프노드에서 연결 리스트를 사용


**특징**
- *리프노드에만 Data 를 저장*
- 중간노들은 찾아가기 위한 key 값만 저장
- 리프노드의 부모 key 는 리프노드의 첫번째 노드보다 작거나 같을 수 있기 때문에 중복되는 key 발생
- *연결 리스트(Linked List)* 로 서로 연결

### B+Tree 가 더 선호되는 이유
- **범위 검색 유리** - 연결 리스트 덕분
- **더 많은 키를 하나의 노드에 저장**
	>B+Tree 의 중간 노드들은 key 값과 자식 노드 포인터만 보유하므로 같은 디스크 블록 크기라도 B-Tree 보다 더 많은 key 를 저장한다.
	> 이로써 트리의 전체 높이가 더 낮게 유지 = 디스크 I/o 횟수 더 낮음 = 검색 속도 증가
	
- **풀스캔 성능 더 좋음**
