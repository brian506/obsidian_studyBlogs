#database #spring #backend 

# 개요

둘 이상의 사용자가 데이터베이스에 접근해서 동시에 수정 작업을 하면 충돌이 일어날 수도 있다.

동시성 제어를 위해서 단일 컴포넌트 내에서는 __비관적 락__ , __낙관적 락__ 이 쓰이고, 분산된 서버 또는 데이터베이스 환경에서는 __레디스 락__ 이 쓰인다.

이 락들은 데이터베이스 엔진(InnoDB)의 메모리에서 관리된다.
메모리 공간에서 Lock Manager 가 락 권한을 부여한다.
___

# Syncronized

**개념** : 자바 컴파일러가 syncronized 키워드를 컴파일하면 객체 내에 있는 **모니터 락**을 획득하게 된다.
자바가 관리하는 스레드 제어 장치이기 때문에 트랜잭션과 관련 없다.
#### 동작 원리

1. 스레드가 synchronized 블록에 진입하면 해당 **객체의 모니터 락을 획득**하고, 블록을 벗어날 떄 락을 해제하게 된다.
2. 스레드가 객체의 모니터 락을 획득하려고 할 때, 이미 다른 스레드가 모니터 락을 보유하고 있다면, 현재 스레드는 **락이 해제될 때까지 대기 상태**에 들어간다.
3. 이때 해당 스레드의 상태는 `RUNNABLE` 에서 `BLOCKED`상태로 바뀌고, **락을 획득할 때까지 무한대기**한다.
4. `BLOCKED`인 스레드는 CPU 스케줄링에 들어가지 않고 대기한다.

#### 예시

스레드1, 스레드2가 있다고 가정해보자.
1. 스레드1은 먼저 모니터 락을 획득한다.
2. 스레드1은 트랜잭션을 시작하고 로직을 수행한다.
3. 스레드1의 메서드는 끝이 나고, 모니터 락을 반납한다.
4. ---스레드1은 아직 커밋되지 않았다고 하자---
5. 스레드2가 다음으로 모니터 락을 획득한다.
6. 스레드2는 스레드1이 아직 커밋하지 않았으므로 스레드1의 커밋 전의 데이터를 읽게 된다.
7. ---스레드1 커밋---
8. 스레드2는 마찬가지로 로직을 수행했지만, 스레드1의 결과를 반영하지 못한다.

- **즉 syncronized 는 트랜잭션 밖의 메서드에서 실행해야 한다.**
- 단일 서버에서만 사용가능하다.

# 비관적 락(Pessimistic Lock)

__개념__ : 테이블의 row 에 접근 시 락을 걸고 다른 락이 걸려 있지 않을 경우에만 수정을 가능하게 한다.

락 종류 : 
- **공유락(Shared Lock)** : 읽기 요청일 때 걸리는 락
	- 읽기 작업일 때 동시 접근 가능
	- 쓰기 작업 막음
	- `LockModeType.PESSIMISTIC_READ`

- **배타락(Exclusive Lock)** : 쓰기 요청일 때 걸리는 락
	 - 트랜잭션이 완료될 때까지 유지
	 - 쓰기 / 읽기 작업 모두 막음
	 - `LockModeType.PESSIMISTIC_WRITE`
	 - `SELECT ~ FOR UPDATE`

#### 동작원리

![사진](../../images/lock1.png)

1. 트랜잭션 1 에서 테이블의 Id 2번을 읽음
2. 트랜잭션 2 에서 테이블의 Id 2번을 읽음
3. 트랜잭션 2에서 테이블의 Id 2번의 name 수정 요청
	- 하지만 트랜잭션 1에서 이미 공유락을 걸었기 때문에 수정 불가
4. 트랜잭션 1 에서 트랜잭션 해제(commit) 이후
5. Blocking 되어있던 트랜잭션 2의 update 요청 처리

- 만약 DB 에 배타락이 걸려있을 때
	- **단순 읽기** : 락이 걸리기 전의 원본 데이터(snap shot)를 보여주기 때문에 가능하다.
	- **쓰기** : 무조건 대기
	- **락을 거는 읽기** : 무조건 대기

- 자원의 row에 락을 거는 것이기 때문에, 다른 메서드가 해당 자원에 진입을 못하게 될 수 있다.

#### `PESSIMISTIC_READ(공유락)`일때의 데드락 상황`

사용자 A와 B가 동시에 예매를 시도하려는 상황(`PESSIMISTIC_READ`)

1. 사용자 A가 먼저 공유락을 획득
2. 공유락은 조회는 공유할 수 있으므로 사용자B도 공유락 획득
3. 사용자 B가 해당 티켓 수를 `UPDATE` 하려고 하지만, 사용자 A의 공유락 때문에 대기 (공유락은 쓰기 작업은 락 걸림)
4. 사용자 A도 해당 티켓 수를 `UPDATE` 하려고 하지만, 사용자 B의 공유락 때문에 대기
5. 사용자 A, 사용자 B 모두 서로의 락이 해제될 때까지 무한정 기다리게 된다
6. 데드락 발생!

___


# 낙관적 락(Optimistic Lock)

**개념** : 자원에 락을 걸지 않고, version 같은 별도의 컬럼으로 충돌을 확인한다.

수정할 때 수정했다고 명시하여 다른 트랜잭션이 동일한 조건으로 값을 수정할 수 없게 하는 것이다.
충돌이 발생했을 때 DB 가 아닌 애플리케이션 단에서 처리한다.

#### 동작원리

![사진](../../images/lock2.png)

1. 트랜잭션 A가 Id 2번을 읽음
2. 트랜잭션 B가 Id 2번을 읽음
3. B 가 먼저 테이블의 Id 2번, version 1인 row 값 갱신(version = 2)
4. 이후 A 가 테이블의 Id 2번, version 1인 row 값 갱신 시도하지만 실패
	- 이미 version 2로 업데이트 되었기 때문에 A 는 해당 row 를 업데이트 하지 못함

#### JPA <-> DB 동작 과정
1. **SELECT** : DB에서 가져와 영속성 컨텍스트에 올린다.
2. **Logic** : 애플리케이션에서 값을 변경한다.
3. **UPDATE** : 변경된 값을 DB로 보낸다.(where 절로 해당 version 으로 요청)

```java
UPDATE ticket_types
set
	issued_quantity = [읽었을 때의 수량],
	version = version + 1 // 버전 증가
WHERE
	id = 2
	AND version = 1
```

- 낙관적 락은 결국 DB 내에서 `Version` 값을 기준으로 락 권한을 얻는다.
- 자원에 락을 거는 것이 아닌 어플리케이션 단에서 처리한다.

___

# 레디스 락

 **분산 락**을 활용하여 메모리를 사용해 더 빠르게 락을 획득 및 해제할 수 있다.
 
 __Pub/Sub__ 방식 : 채널을 하나 만들고 락을 점유 중인 스레드가 대기중인 스레드에게 해제를 알려주면 알림을 받은 대기중인 스레드가 락 획득을 시도하는 방식이다.
 - Lettuce 는 **spin Lock** 을 사용하여 시스템에 부하를 줄 수 있다.
 - 락 획득 재시도를 기본으로 제공한다.

	**동작 순서** 
		1. 구독(subscribe) : 락을 획득하기 위해 대기하게 되는데, 이때 락 채널을 구독하고 대기한다.
		2. 알림(publish) : 락을 가지고 있던 클라이언트가 작업을 마치고 락을 해제하면, 채널에 락이 해제되었음을 알린다.
		3. 메시지를 받은 대기 클라이언트들은 다시 락 획득을 시도한다.

**spin lock** : 락을 획득하려는 스레드가 락을 사용할 수 있는 지 반복적으로 확인하면서 락 획득을 시도하는 방식
	- 락을 빠르게 획득할수는 있지만 시스템에 부하를 줄 수 있다.

# 선택기준
### 📌 비관적 락을 선택하는 경우
- 충돌 가능성이 높을 때
- 데이터 일관성이 중요할 때
- 롤백 비용이 높은 작업을 할 때
- Ex) : 은행 시스템, 재고 관리, 좌석 예약

### 📌 낙관적 락을 선택하는 경우
- 읽기 작업이 많고 충돌이 별로 없을 떄
- 높은 동시성이 필요할 떄
- 성능이 중요할 때
-  Ex) :  게시판 조회수, 사용자 프로필 업데이트, 캐시 시스템

# 성능 비교

| 구분     | 낙관적 락   | 비관적 락 |
| ------ | ------- | ----- |
| 읽기 성능  | 우수      | 보통    |
| 쓰기 성능  | 충돌 시 저하 | 항상 보통 |
| 동시성    | 높음      | 낮음    |
| 메모리 사용 | 적음      | 많음    |
| 구현 복잡도 | 높음      | 낮음    |
## ✨ 참고: 데이터 정합성을 위한 기본 수칙

1. **락은 공유 자원만 걸어라**
    
2. **트랜잭션 범위를 작게 유지해라**
    
3. **연관관계 없다고 해서 데이터가 망가지는 건 아님** → 저장 순서, 로직 흐름이 중요