#database #mysql 

## MVCC(Multi-Version Concurrency Control) 란?

DB 내에서 동시성 제어를 하기 위해 기존에는 **LOCK**을 사용했지만 처리 속도가 현저히 떨어진다.
이러한 기존 방법의 처리 속도를 극복하기 위해 **MVCC**에 대해서 알아보자.

**MVCC**는 동시 접근을 허용하는 DB에서 동시성을 제어하기 위해 사용하는 방법 중 하나이다.
MVCC는 원본의 데이터와 변경중인 데이터를 동시에 유지하는 방식으로, 원본 데이터에 대한 **SNAPSHOT**을 백업하여 **version**별로 보관한다.

만약 두 가지 버전의 데이터가 있는 상황에서 사용자가 DB에 접근할 때 먼저 SNAPSHOT을 읽는다. SNAPSHOT으로 변경이 완료되면 최종적으로 변경된 데이터를 디스크에 반영하고, 변경이 취소되면 원본 SNAPSHOT을 바탕으로 데이터를 복구한다.

결론적으로 MVCC 는 SNAPSHOT을 이용하는 방식으로, 기존의 데이터를 덮어 씌우는 것이 아니라 기존의 데이터를 바탕으로 변경된 데이터와 비교하여 변경된 내용을 기록한다.

### 장점
- **LOCK**이 필요없기 때문에 빠르게 작동
- 다른 사람이 데이터를 삭제하거나 수정해도 영향을 받지 않고 SNAPSHOT으로 데이터 사용 가능
- 읽기 작업은 어떤 쓰기 작업에 의해서도 차단되지 않는다.

### Undo 로그?

Undo 로그는 트랜잭션과 격리 수준을 보장하기 위해 백업해둔 **변경 전**의 데이터이다.

- **트랜잭션 보장**: 트랜잭션이 롤백되면 변경된 데이터를 백업된 이전 버전으로 복구시킨다.
- **격리 수준 보장**: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 격리 수준에 맞는 데이터를 반환한다.

Undo 로그도 트랜잭션만큼 저장공간을 생성하게 되므로 관리가 중요하므로 아래와 같은 상황에서는 좋지 않다.
- 대량의 데이터를 변경 또는 삭제하는 경우
- 트랜잭션이 길 경우

### Redo 로그?

Redo 로그는 **데이터 변경 후의 내용**을 기록해두는 저장 공간이다.
메모리의 변경 사항을 디스크에 반영하기 전에 DB 서버가 다운됐을 때 방지하기 위함이다.

### 버퍼풀(Buffer Pool)?

디스크에 저장된 테이블과 인덱스 정보를 캐싱해두는 공간이다.

버퍼풀은 디스크에 저장하기 전에 임시 저장하기 위한 메모리이므로 읽기 작업시에 디스크 접근 횟수를 줄일 수 있다. 그리고 쓰기 작업을 한번에 처리할 수 있는 버퍼 역할도 같이 한다.
영속성 컨텍스트와 비슷한 역할을 한다고 보면된다.


### 예시
MySQL은 **Undo Log** 을 통해 MVCC 를 구현한다.

![[../../images/innodb.png]]

만약 위와 같은 테이블이 있을 때 `UPDATE member SET area = "경기" WHERE id =1` 쿼리를 발생했다고 하자.

![[../../images/innodb2.png]]

- `COMMIT` 여부와 무관하게 InnoDB 는 새로운 값이 반영된다.
- Undo 로그에는 변경 전의 값만 복사된다.
- Undo 로그는 `COMMIT or ROLLBACK` 을 호출하여 버퍼풀의 데이터도 복구되고, 더 이상 Undo 영역이 필요없어질 때 삭제된다.

##### 만약 `SELECT * FROM member WHERE id = 1` 쿼리를 발생하게 된다면 어떻게 될까?
결과는 트랜잭션 격리 수준에 따라서 다르다.

**READ UNCOMMMITTED** 일 때 : `COMMIT` 여부와 무관하게 *버퍼 풀의 데이터를 읽는다.*
**READ COMMITTED 이상**일때 : 변경되기 이전의 *Undo 로그 영역의 데이터를 읽는다.*

>이렇게  여러 트랜잭션 사이에서 SNAPSHOT 을 통해 여러 버전을 관리하여 동시성 제어를 할 수 있다.
즉, MVCC 는 트랜잭션 격리 수준을 달성하기 위한 도구로 사용된다.

트랜잭션 격리수준을 이해하기 위해 이전에 [[스토리지 엔진 수준의 락 (레코드 락, 갭 락, 넥스트 키 락)]] 이해가 필요하다.

## 트랜잭션 격리수준이란?

**트랜잭션의 격리 수준**이란 **여러 트랜잭션이 동시에 처리될 때**, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다.
즉, 여러 트랜잭션이 동시에 처리될 때의 데이터 일관성을 보장하기 위함이다.

트랜잭션 격리 수준 종류
- SERIALIZABLE (레벨 @@@@)
- REPEATABLE  READ (레벨 @@@)
- READ COMMITTED (레벨 @@)
- READ UNCOMMITTED (레벨 @)

## SERIALIZABLE

가장 엄격한 격리 수준으로 트랜잭션을 순차적으로 진행한다.

**특징** 
- 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로 어떠한 데이터 부정합도 일어나지 않음
- 동시 처리 성능 매우 안좋음
- 해당 레코드에 대한 쓰기/읽기 작업에 모두 *Lock*

웬만해선 잘 사용안함 - 너무 빡센 격리수준이여서

## REPEATABLE READ

**MVCC**를 활용해 SNAPSHOT인 Undo 로그에 변경 이전의 레코드를 백업해 두어, 트랜잭션이 끝날 때까지 Undo 로그만 읽도록 한다.

**EX)** 만약 트랜잭션이 시작할 때 stock = 100 이고, 중간에 stock = 50으로 바꿔도 처음 stock =100 값을 읽게 된다.

**한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합**이 발생할 수 있다.

>mysql의 기본값
>
## READ COMMITTED

READ COMMITTED 는 **`COMMIT` 된 데이터**만 조회할 수 있다.

- Phantom Read, Non-Repeatable(반복 읽기 불가능) 문제 발생

**EX)**

1. 사용자 A가 데이터는 변경했지만 아직 `COMMIT`은 안한 상태 - T1
2. 사용자 B 테이블 조회
3. 사용자 B는 아직 T1 이`COMMIT` 되지 않았으므로 변경 전의 Undo 로그의 데이터를 읽게 됨
4. T1 `COMMIT`
5. 사용자 B 테이블 다시 조회
6. 사용자 A가 변경한 값을 사용자 B는 조회하게 됨 - 첫 조회와 데이터 값이 다름 -> Non-Repeatable 문제 발생

애초에 `COMMIT` 된 데이터만 읽을 수 있기 때문에 트랜잭션 내에서의 조회와 트랜잭션 밖에서 실행되는 SELECT 와 차이가 별로 없음

> 대부분의 DB, Oracle, PostgreSQL 의 기본값


## READ UNCOMMITED

커밋하지 않은 데이터도 접근할 수 있는 격리 수준이다.
다른 트랜잭션이 커밋,롤백되지 않아도 즉시 보이게 된다.

이렇게 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 **Dirty Read**라고 한다. 데이터가 조회되었다가 사라지기도 하는 현상이 일어나기 때문에
웬만하면 READ COMMITTED 이상의 격리 수준을 사용해야 한다.