#database #mysql 

MySQL 이 사용하고 있는 스토리지 엔진인 InnoDB 는 높은 동시성을 위해 테이블 전체가 아닌 레코드(ROW) 단위로 락을 거는 것을 기본으로 한다.
쓰기 작업에는 조건만 만족하면, 아래 락들이 기본적으로 무조건 걸린다.
해당 레코드가 **인덱스로 구성된** 필드값을 대상으로 적용된다.

## 레코드 락 (Record Lock)

**개념** : **인덱스 레코드**에 하나만 정확히 *Lock*
**발생 조건** : PK나 유니크 인덱스로 하나의 레코드만 조회해서 수정할 때 

**EX)**
```mysql
UPDATE ticket_stock SET stock = 199 WHERE ticket_type_id = 10;
```
- `id = 10`인 레코드에만 락이 걸린다.
- `id = 10`인 레코드를 수정할 수는 없지만, 다른 `id`는 수정 가능하다.

## 갭 락 (Gap Lock)

**개념** : 인덱스 레코드 사이의 틈을 *Lock*
**목적** : 유령읽기 방지
	- 틈 사이에 새로운 데이터가 `INSERT`되는 것을 막음
**발생 조건** : **PK 가 아닌 일반 인덱스**로 **범위**를 조회하거나, 존재하지 않는 값을 조회할 때

**EX)**
가정 :현재 stock 이 110~140 인 데이터는 테이블에 없다.
	stock 이 100, 150인 데이터 두 개 존재
```mysql
SELECT * FROM ticket_stock WHERE stock BETWEEN 110 AND 140 FOR UPDATE;
```
- stock = 100, stock = 150 사이의 틈을 *LOCK*
- 이 때 다른 트랜잭션은 110~140 사이의 데이터를 `INSERT` 하지 못한다.

## 넥스트 키 락 (Next Key Lock)

**개념** : 레코드락 + 갭락
	- 특정 인덱스 레코드를 잠그면서, 레코드 이전의 틈까지 함께 *LOCK*
**발생 조건** : `REPEATABLE READ` 격리 수준에서 유니크 하지 않은 인덱스를 조회하거나, 범위 검색을 할 때

**EX)**
가정 : stock 이 100, 150인 데이터 두 개 존재
```mysql
UPDATE ticket_stock SET ticket_name = 'C공연 특별석' WHERE stock = 150;
```
1. **레코드 락** : stock = 150 인 레코드 자체에 *Lock*
2. **갭락** : stock = 150 이전의 틈(stock = 100 ~ 150)에 *Lock*
- 다른 트랜잭션은 C공연 레코드를 수정할 수 없고, stock = 100~150 인 레코드에 대해서도 수정 불가 -> 대기상태

**EX)**
가정 : stock 이 10인 데이터만 존재
배타락이 걸린 stock 에 대해서 stock > 10 인 Stock 을 먼저 조회할때
```java
SELECT ticket_stock WHERE stock > 10 FOR UPDATE
```

- stock > 10 인 모든 stock 들에 대해 락을 건다.
- stock < 10 인 stock들은 락을 걸지 않는다.