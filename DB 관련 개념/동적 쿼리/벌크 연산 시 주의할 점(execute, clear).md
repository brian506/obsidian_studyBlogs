#spring #queryDSL 


## 벌크 연산이란?(Bulk Operation)

벌크 연산이란 한번의 쿼리로 수많은 데이터를 동시에 수정하거나 삭제하는 작업을 말한다.

만약 Food(식재료), Member 테이블이 있다고 가정해보자.
한 Member 가 가지고 있는 식재료가 여러 개일 때 삭제하려고 한다.

모든 식재료를 조회해서 영속성 컨텍스트에 올려두고 삭제 쿼리를 날리면 식재료 개수만큼 날려야 하므로 매우 비효율적이다.
모든 식재료를 영속성 컨텍스트에 올림으로써 메모리가 낭비되고, 더티체킹을 식재료 개수만큼 해야된다는 점에서 비효율적인 쿼리가 발생할 것이다.

이를 해결하기 위해 영속성 컨텍스트에 데이터를 올려두지 않고, 바로 DB 에서 쿼리 1번으로 모두 삭제하는 방법이다.

## 주의할점

벌크 연산을 사용할 때 주의할점이 몇개 있다.

> 만약 Member 데이터를 조회한 후 Member 데이터에 대한 벌크 연산을 수행한다면 영속성 컨텍스트에 있는 Member 와 DB 에 있는 Member의 데이터가 다를 수 있으므로 주의해야한다.

**데이터 정합성 해결 방법**

- `em.refresh()`사용
	- 정확한 Member 데이터를 다시 사용하기 위해 벌크 연산 후 DB 에서 다시 조회한다.
- 벌크 연산 먼저 실행
	- 벌크 연산 먼저 실행하고 데이터를 조회하면 된다.
- 벌크 연산 후 영속성 컨텍스트 초기화


아래 코드는 회원 탈퇴 시에 모든 정보를 soft delete 하는 상황이다.
아래 코드에서 회원 삭제가 제대로 이뤄지지 않는다. 이유가 뭘까?

![](../../images/pooLie%20void%20aithira(String%20treerter)%20d.png)![](../../images/coverride%201usage.png)

먼저, 회원 정보를 조회하여 `delete()`연산을 수행하고 있다.
여기서 `delete()` 는 soft delete 로 상태값을 `UPDATE`한다.

즉, `oauthRepository` 까지의 수행 동작이 영속성 컨텍스트에 올라가 있다고 볼 수 있다.
하지만 아래의 `FoodManager` 코드를 한번 보자.
한 Member 의 모든 Food 데이터를 soft delete 하려고 한다.
여기서 사용하는 `UPDATE` 문으로 벌크 쿼리를 수행한다. - `execute()`

그리고 벌크 쿼리를 사용하기 전에 영속성 컨텍스트를 초기화하고 있다. - `.clear()`
벌크 연산이 끝나고 영속성 컨텍스트를 초기화하면, 앞서 Member 를 조회하고 `delete()`를 수행한 영속성 컨텍스트에 있는 객체가 사라지게 된다.

이렇게 트랜잭션이 마무리 되면, Member 의 변경사항이 반영되지 않을 것이다.

이 상황에서는 Member 를 조회하고 Member 데이터를 다시 사용하지 않으므로 `.clear()` 로 영속성 컨텍스트를 초기화할 필요가 없다.
