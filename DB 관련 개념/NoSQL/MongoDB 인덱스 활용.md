#mongoDB #NoSQL 

## 인덱스를 사용하지 않았을 때

먼저 예시를 살펴보자,

사용자의 채팅방을 서비스 내의 사용자 역할에 따라 보낸 메시지를 기준으로 최신순 조회하는 상황
```sql
db.rooms.find({'participants.user_id' : 'some_user_id', 'participants.user_type' : 'SOME_TYPE'}).sort({'last_message_at' : -1})
```

##### 인덱스를 사용하지 않을 때 동작 방식
**1.Document 풀스캔**
- Rooms 컬렉션 안에 있는 모든 Document 들을 저장된 순서로 모두 읽음
**2.조건 필터링**
- 읽어들인 Document 들을 `find(user_id,user_type)` 조건으로 필터링
**3.정렬**
- 필터링된 Document 들을 `last_message_at` 순으로 내림차순(-1) 정렬

**인덱스를 사용하지 않으면 풀스캔(Full Scan)을 하게 되어 데이터가 많은 상황에서는 성능 저하가 발생하게 된다.**

## Index

위처럼 모든 데이터를 읽지 않고 Index 라는 저장공간을 따로 생성해서 필요한 컬럼에 한해서 인덱스를 참조하여 조회 성능을 높인다.
MongoDB 인덱스는 [[B-Tree 자료구조]] 기반으로 동작한다.

위의 예시를 기반으로 복합 인덱스를 생성하여 조회 속도를 향상시키는 상황을 보자.

```mysql
@CompoundIndexes({  
        @CompoundIndex(  
                name = "idx_part_user_type_last",  
                def = "{'participants.user_id' : 1, 'participants.user_type' : 1 , 'last_message_at' : -1}"  
        )  
})
```

**1.인덱스 생성**
- `user_id,user_type,last_message_at` 필드값과 Room 주소를 B-Tree 기반으로 데이터들의 Document 안의 주소를 인덱스 안에 저장
- 인덱스 내에서 필드값에 따라 오름차순(1) 또는 내림차순(-1)으로 정렬
**2.인덱스 조회**
- 쿼리가 들어오면 B-Tree 기반으로 이미 저장된 데이터들의 위치 주소값들을 조회
- 데이터베이스는 먼저 인덱스 테이블부터 조회
**3.값 반환**
- 왼쪽부터 차례로 필터링 수행 - 보통 카디널리티가 높은 컬렉션을 앞에다가 둠
- 인덱스에서 찾은 주소를 이용해 원본 테이블의 실제 데이터에 바로 접근하여 반환

*장점* 
- 풀스캔을 하지 않고 인덱스 스캔을 이용하여 조회속도 향상
- 쿼리의 `sort()` 연산이 인덱스를 통해 먼저 수행되기 때문에 별도의 정렬 작업이 없어 메모리 효율 증가
- `unique index`를 사용하면 특정 필드에 중복되는 값 생성 방지

## 인덱스를 사용하면 좋을 경우

**읽기 작업이 빈번한 컬렉션일때**
- **`find()`쿼리(where 절)**
	- `db.collection.find({ status: "A" })`처럼 특정 필드로 자주 검색할때
- **빈번하게 사용되는 정렬 (`sort()`) 기준 필드**:
    - `db.collection.find({}).sort({ createdAt: -1 })`처럼 최신순으로 자주 정렬할 때.
- **고유성을 강제해야 하는 필드**:
    - 사용자의 **이메일(email)** 또는 **사용자 ID(username)**처럼 중복되면 안 되는 필드.
- **복합 인덱스의 순서**:
	- 동등조건(=)을 사용하는 필드를 인덱스의 앞쪽에 배치, 정렬 또는 범위 조건을 사용하는 필드는 인덱스의 뒤쪽에 배치하는 것이 좋음

## 인덱스를 사용하면 안좋은 경우

- **쓰기(Insert,Delete,Update)작업이 빈번한 컬렉션**
- **카디널리티가 낮은 컬렉션**
	- 예) 남/여, 활성/비활성
- **컬렉션의 크기가 매우 작을 때**:
	- 컬렉션에 문서가 몇 백 개 정도에 불과하다면, 인덱스 검색 시간과 문서 직접 스캔 시간의 차이가 미미하므로 인덱스 생성에 따른 오버헤드가 더 큼
- **자주 사용되지 않는 컬렉션**

## 커버드 쿼리 (Covered Query)

- **개념**: 쿼리가 인덱스에 **포함된 필드만**을 요구하고, 정렬도 인덱스 순서대로 수행될 때, MongoDB는 **실제 문서에 접근하지 않고** 인덱스 자체에 저장된 데이터만으로 쿼리를 처리
- **장점**: 디스크 I/O를 최소화하여 성능 극대화






